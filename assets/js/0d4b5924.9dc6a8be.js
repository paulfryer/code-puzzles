"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4593],{1470:(e,n,t)=>{t.d(n,{A:()=>S});var r=t(6540),i=t(4164),a=t(3104),s=t(6347),o=t(205),l=t(7485),c=t(1682),d=t(679);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(i),(0,r.useCallback)(e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})},[i,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,a=h(e),[s,l]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a})),[c,u]=m({queryString:t,groupId:i}),[g,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,d.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&i.set(e)},[n,i])]}({groupId:i}),v=(()=>{const e=c??g;return p({value:e,tabValues:a})?e:null})();(0,o.A)(()=>{v&&l(v)},[v]);return{selectedValue:s,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),x(e)},[u,x,a]),tabValues:a}}var x=t(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(4848);function b({className:e,block:n,selectedValue:t,selectValue:r,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),c=e=>{const n=e.currentTarget,i=o.indexOf(n),a=s[i].value;a!==t&&(l(n),r(a))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:r})=>(0,j.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:c,...r,className:(0,i.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function f({lazy:e,children:n,selectedValue:t}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function y(e){const n=g(e);return(0,j.jsxs)("div",{className:(0,i.A)("tabs-container",v.tabList),children:[(0,j.jsx)(b,{...n,...e}),(0,j.jsx)(f,{...n,...e})]})}function S(e){const n=(0,x.A)();return(0,j.jsx)(y,{...e,children:u(e.children)},String(n))}},6652:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"puzzles/minimizing-permutations","title":"Minimizing Permutations","description":"Problem Statement","source":"@site/docs/puzzles/minimizing-permutations.mdx","sourceDirName":"puzzles","slug":"/puzzles/minimizing-permutations","permalink":"/docs/puzzles/minimizing-permutations","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/minimizing-permutations.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Median Stream","permalink":"/docs/puzzles/median-stream"},"next":{"title":"Nodes in a Subtree","permalink":"/docs/puzzles/nodes-in-a-subtree"}}');var i=t(4848),a=t(8453),s=t(1470),o=t(9365);const l={},c="Minimizing Permutations",d={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Visual Understanding",id:"visual-understanding",level:2},{value:"State Space Graph Visualization",id:"state-space-graph-visualization",level:3},{value:"Approach Breakdown",id:"approach-breakdown",level:2},{value:"Why BFS?",id:"why-bfs",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Step-by-Step BFS Solution",id:"step-by-step-bfs-solution",level:3},{value:"Optimized Implementation with Better State Encoding",id:"optimized-implementation-with-better-state-encoding",level:3},{value:"Advanced State Representation",id:"advanced-state-representation",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Time Complexity: <strong>O(N! \xd7 N\xb2)</strong>",id:"time-complexity-on--n",level:3},{value:"Space Complexity: <strong>O(N!)</strong>",id:"space-complexity-on",level:3},{value:"Edge Cases Deep Dive",id:"edge-cases-deep-dive",level:2},{value:"Pancake Sorting Connection",id:"pancake-sorting-connection",level:3},{value:"Operation Counting Examples",id:"operation-counting-examples",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Follow-Up Questions",id:"follow-up-questions",level:3},{value:"Advanced Variations",id:"advanced-variations",level:2},{value:"1. <strong>Weighted Operations</strong>",id:"1-weighted-operations",level:3},{value:"2. <strong>Bidirectional BFS</strong>",id:"2-bidirectional-bfs",level:3},{value:"3. <strong>Limited Operations</strong>",id:"3-limited-operations",level:3},{value:"4. <strong>Path Reconstruction</strong>",id:"4-path-reconstruction",level:3},{value:"Mathematical Properties",id:"mathematical-properties",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Problems",id:"practice-problems",level:2}];function h(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"minimizing-permutations",children:"Minimizing Permutations"})}),"\n","\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given a permutation P of integers from 1 to N, find the ",(0,i.jsx)(n.strong,{children:"minimum number of reverse operations"})," needed to sort the array into increasing order. Each operation reverses a contiguous sub-portion (a_i, ..., a_j) of the permutation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Function Signature"}),": ",(0,i.jsx)(n.code,{children:"int minOperations(int[] arr)"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Input"}),": Permutation of integers 1 to N where 1 \u2264 N \u2264 8",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Output"}),": Minimum number of reverse operations to sort the permutation"]}),"\n",(0,i.jsxs)(n.admonition,{title:"Real-World Applications",type:"tip",children:[(0,i.jsx)(n.p,{children:"This algorithmic pattern appears in:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DNA Sequence Analysis"}),": Gene reversal operations in bioinformatics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robot Path Planning"}),": Finding minimum moves to reach target configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Puzzle Solving"}),": Optimal solutions for sliding puzzles and sorting games"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compiler Optimization"}),": Instruction reordering with reversal constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Structure Operations"}),": Array manipulation with limited operations"]}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Master breadth-first search (BFS) for shortest path problems"}),"\n",(0,i.jsx)(n.li,{children:"Understand state space exploration in combinatorial problems"}),"\n",(0,i.jsx)(n.li,{children:"Learn permutation representation and manipulation techniques"}),"\n",(0,i.jsx)(n.li,{children:"Apply graph algorithms to optimization problems"}),"\n",(0,i.jsx)(n.li,{children:"Practice hash-based state tracking and cycle detection"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"visual-understanding",children:"Visual Understanding"}),"\n",(0,i.jsxs)(n.p,{children:["Let's trace through example: ",(0,i.jsx)(n.code,{children:"[3, 1, 2]"})," \u2192 ",(0,i.jsx)(n.code,{children:"[1, 2, 3]"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Initial: [3, 1, 2]\nGoal:    [1, 2, 3]\n\nBFS Level 0: [3, 1, 2]\n\nBFS Level 1: Generate all possible reverse operations\n- Reverse [0,1]: [3,1,2] \u2192 [1,3,2]\n- Reverse [0,2]: [3,1,2] \u2192 [2,1,3]  \n- Reverse [1,2]: [3,1,2] \u2192 [3,2,1]\n\nBFS Level 2: From [1,3,2]\n- Reverse [1,2]: [1,3,2] \u2192 [1,2,3] \u2705 FOUND!\n\nMinimum operations: 2\nPath: [3,1,2] \u2192 [1,3,2] \u2192 [1,2,3]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-space-graph-visualization",children:"State Space Graph Visualization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"This creates a graph where:\n- Nodes = All possible permutations\n- Edges = Valid reverse operations\n- Goal = Find shortest path to sorted permutation\n\nExample for N=3:\n[1,2,3] \u2190 target\n   \u2191\n[1,3,2] \u2190 [2,3,1] \u2190 [3,2,1]\n   \u2191         \u2191         \u2191\n[3,1,2] \u2192 [2,1,3] \u2192 [3,2,1]\nstart\n\nBFS guarantees finding the minimum path!\n"})}),"\n",(0,i.jsx)(n.h2,{id:"approach-breakdown",children:"Approach Breakdown"}),"\n",(0,i.jsx)(n.h3,{id:"why-bfs",children:"Why BFS?"}),"\n",(0,i.jsxs)(n.p,{children:["The minimizing permutations problem is a ",(0,i.jsx)(n.strong,{children:"shortest path problem"})," in disguise:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Equal Edge Weights"}),": All reverse operations have cost 1"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Finite State Space"}),": N! possible permutations (manageable for N \u2264 8)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Target"}),": One goal state (sorted permutation)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimal Substructure"}),": Shortest path to goal involves shortest subpaths"]}),"\n"]}),"\n",(0,i.jsxs)(s.A,{children:[(0,i.jsxs)(o.A,{value:"dfs",label:"\u274c DFS Approach",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Depth-First Search"}),": Explores deeply but doesn't guarantee minimum"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// DFS finds A solution, but not necessarily the optimal one\npublic int DFS(int[] arr, int target, Set<string> visited) {\n    if (IsSorted(arr)) return 0;\n    \n    int minOps = Integer.MAX_VALUE;\n    // Try all reverse operations recursively\n    for (each possible reverse) {\n        int result = 1 + DFS(newState, target, visited);\n        minOps = Math.Min(minOps, result);\n    }\n    return minOps; // May not be optimal!\n}\n"})})]}),(0,i.jsxs)(o.A,{value:"bfs",label:"\u2705 BFS Approach",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Breadth-First Search"}),": Level-by-level guarantees minimum operations"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// BFS guarantees finding minimum operations\nQueue<(state, operations)> queue;\nSet<string> visited;\n// Explore all states at distance k before distance k+1\n// First time we reach target = minimum operations\n"})})]})]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"step-by-step-bfs-solution",children:"Step-by-Step BFS Solution"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="MinimizingPermutations.cs"',children:'using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass MinimizingPermutations \n{\n    static void Main(string[] args) \n    {\n        // Test case 1: Basic example\n        int[] arr1 = {3, 1, 2};\n        Console.WriteLine($"Input: [{string.Join(", ", arr1)}]");\n        Console.WriteLine($"Minimum operations: {minOperations(arr1)}"); // Expected: 2\n        \n        // Test case 2: Already sorted\n        int[] arr2 = {1, 2, 3};\n        Console.WriteLine($"Input: [{string.Join(", ", arr2)}]");\n        Console.WriteLine($"Minimum operations: {minOperations(arr2)}"); // Expected: 0\n        \n        // Test case 3: Reverse sorted\n        int[] arr3 = {3, 2, 1};\n        Console.WriteLine($"Input: [{string.Join(", ", arr3)}]");\n        Console.WriteLine($"Minimum operations: {minOperations(arr3)}"); // Expected: 1\n        \n        // Test case 4: Complex permutation\n        int[] arr4 = {4, 3, 2, 1};\n        Console.WriteLine($"Input: [{string.Join(", ", arr4)}]");\n        Console.WriteLine($"Minimum operations: {minOperations(arr4)}"); // Expected: 1\n    }\n    \n    private static int minOperations(int[] arr) \n    {\n        // Early termination: check if already sorted\n        if (IsSorted(arr)) \n        {\n            return 0;\n        }\n        \n        // Target state: sorted permutation [1, 2, 3, ..., N]\n        string target = string.Join(",", Enumerable.Range(1, arr.Length));\n        \n        // BFS setup\n        var queue = new Queue<(string state, int operations)>();\n        var visited = new HashSet<string>();\n        \n        // Initial state\n        string initialState = string.Join(",", arr);\n        queue.Enqueue((initialState, 0));\n        visited.Add(initialState);\n        \n        // BFS exploration\n        while (queue.Count > 0) \n        {\n            var (currentState, operations) = queue.Dequeue();\n            \n            // Generate all possible next states by reversing subarrays\n            var currentArray = ParseState(currentState);\n            \n            // Try all possible reverse operations [i, j] where i < j\n            for (int i = 0; i < currentArray.Length; i++) \n            {\n                for (int j = i + 1; j < currentArray.Length; j++) \n                {\n                    // Create new state by reversing subarray [i, j]\n                    var newArray = (int[])currentArray.Clone();\n                    ReverseSubarray(newArray, i, j);\n                    \n                    string newState = string.Join(",", newArray);\n                    \n                    // Check if we reached the target\n                    if (newState == target) \n                    {\n                        return operations + 1;\n                    }\n                    \n                    // Add to queue if not visited (avoid cycles)\n                    if (!visited.Contains(newState)) \n                    {\n                        visited.Add(newState);\n                        queue.Enqueue((newState, operations + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1; // Should never reach here for valid permutation\n    }\n    \n    private static bool IsSorted(int[] arr) \n    {\n        for (int i = 0; i < arr.Length - 1; i++) \n        {\n            if (arr[i] > arr[i + 1]) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static int[] ParseState(string state) \n    {\n        return state.Split(\',\').Select(int.Parse).ToArray();\n    }\n    \n    private static void ReverseSubarray(int[] arr, int start, int end) \n    {\n        while (start < end) \n        {\n            (arr[start], arr[end]) = (arr[end], arr[start]);\n            start++;\n            end--;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"optimized-implementation-with-better-state-encoding",children:"Optimized Implementation with Better State Encoding"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="OptimizedMinimizingPermutations.cs"',children:"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass MinimizingPermutations \n{\n    private static int minOperations(int[] arr) \n    {\n        int n = arr.Length;\n        \n        // Early termination for already sorted array\n        if (IsSorted(arr)) return 0;\n        \n        // Use integer encoding for more efficient state representation\n        long target = EncodePermutation(Enumerable.Range(1, n).ToArray());\n        long initial = EncodePermutation(arr);\n        \n        var queue = new Queue<(long state, int operations)>();\n        var visited = new HashSet<long>();\n        \n        queue.Enqueue((initial, 0));\n        visited.Add(initial);\n        \n        while (queue.Count > 0) \n        {\n            var (currentState, operations) = queue.Dequeue();\n            \n            // Decode current state back to array\n            var currentArray = DecodePermutation(currentState, n);\n            \n            // Generate all possible reverse operations\n            for (int i = 0; i < n; i++) \n            {\n                for (int j = i + 1; j < n; j++) \n                {\n                    var newArray = (int[])currentArray.Clone();\n                    Array.Reverse(newArray, i, j - i + 1);\n                    \n                    long newState = EncodePermutation(newArray);\n                    \n                    if (newState == target) \n                    {\n                        return operations + 1;\n                    }\n                    \n                    if (!visited.Contains(newState)) \n                    {\n                        visited.Add(newState);\n                        queue.Enqueue((newState, operations + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    // Encode permutation as long integer for efficient hashing\n    private static long EncodePermutation(int[] arr) \n    {\n        long result = 0;\n        for (int i = 0; i < arr.Length; i++) \n        {\n            result = result * 10 + arr[i];\n        }\n        return result;\n    }\n    \n    // Decode long integer back to permutation array  \n    private static int[] DecodePermutation(long encoded, int length) \n    {\n        var result = new int[length];\n        for (int i = length - 1; i >= 0; i--) \n        {\n            result[i] = (int)(encoded % 10);\n            encoded /= 10;\n        }\n        return result;\n    }\n    \n    private static bool IsSorted(int[] arr) \n    {\n        for (int i = 1; i < arr.Length; i++) \n        {\n            if (arr[i] < arr[i - 1]) return false;\n        }\n        return true;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-state-representation",children:"Advanced State Representation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="AdvancedStateEncoding.cs"',children:"// For larger N, use factorial number system (Lehmer code)\nclass AdvancedMinimizingPermutations \n{\n    private static int minOperations(int[] arr) \n    {\n        if (IsSorted(arr)) return 0;\n        \n        // Use Lehmer code for compact permutation representation\n        long target = 0; // Lehmer code for sorted permutation\n        long initial = PermutationToLehmer(arr);\n        \n        var queue = new Queue<(long state, int ops)>();\n        var visited = new HashSet<long>();\n        \n        queue.Enqueue((initial, 0));\n        visited.Add(initial);\n        \n        while (queue.Count > 0) \n        {\n            var (state, ops) = queue.Dequeue();\n            var currentArray = LehmerToPermutation(state, arr.Length);\n            \n            for (int i = 0; i < arr.Length; i++) \n            {\n                for (int j = i + 1; j < arr.Length; j++) \n                {\n                    var newArray = (int[])currentArray.Clone();\n                    Array.Reverse(newArray, i, j - i + 1);\n                    long newState = PermutationToLehmer(newArray);\n                    \n                    if (newState == target) return ops + 1;\n                    \n                    if (!visited.Contains(newState)) \n                    {\n                        visited.Add(newState);\n                        queue.Enqueue((newState, ops + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    private static long PermutationToLehmer(int[] perm) \n    {\n        int n = perm.Length;\n        var available = new List<int>(Enumerable.Range(1, n));\n        long lehmer = 0;\n        long factorial = Factorial(n - 1);\n        \n        for (int i = 0; i < n; i++) \n        {\n            int index = available.IndexOf(perm[i]);\n            lehmer += index * factorial;\n            available.RemoveAt(index);\n            factorial = (i == n - 2) ? 1 : factorial / (n - i - 1);\n        }\n        \n        return lehmer;\n    }\n    \n    private static int[] LehmerToPermutation(long lehmer, int n) \n    {\n        var available = new List<int>(Enumerable.Range(1, n));\n        var result = new int[n];\n        long factorial = Factorial(n - 1);\n        \n        for (int i = 0; i < n; i++) \n        {\n            int index = (int)(lehmer / factorial);\n            result[i] = available[index];\n            available.RemoveAt(index);\n            lehmer %= factorial;\n            factorial = (i == n - 2) ? 1 : factorial / (n - i - 1);\n        }\n        \n        return result;\n    }\n    \n    private static long Factorial(int n) \n    {\n        long result = 1;\n        for (int i = 2; i <= n; i++) result *= i;\n        return result;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,i.jsxs)(n.h3,{id:"time-complexity-on--n",children:["Time Complexity: ",(0,i.jsx)(n.strong,{children:"O(N! \xd7 N\xb2)"})]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Complexity"}),(0,i.jsx)(n.th,{children:"Explanation"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"State Space"})}),(0,i.jsx)(n.td,{children:"N!"}),(0,i.jsx)(n.td,{children:"Maximum possible permutations"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Operations per State"})}),(0,i.jsx)(n.td,{children:"N\xb2"}),(0,i.jsx)(n.td,{children:"All possible reverse operations (i,j) pairs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"BFS Traversal"})}),(0,i.jsx)(n.td,{children:"N!"}),(0,i.jsx)(n.td,{children:"Visit each state at most once"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"For N \u2264 8: 8! = 40,320 states, 8\xb2 = 64 operations per state \u2248 2.5M total operations"}),"\n",(0,i.jsxs)(n.h3,{id:"space-complexity-on",children:["Space Complexity: ",(0,i.jsx)(n.strong,{children:"O(N!)"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Storage"}),": O(N!) for BFS frontier"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visited Set"}),": O(N!) to track explored states"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Representation"}),": O(N) per state or O(1) with encoding"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Total"}),": O(N!) dominated by state tracking"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"edge-cases-deep-dive",children:"Edge Cases Deep Dive"}),"\n",(0,i.jsx)(n.admonition,{title:"Critical Test Cases",type:"warning",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Test comprehensive edge cases:\n\nminOperations([1])           // 0 - single element (trivially sorted)\nminOperations([1, 2])        // 0 - already sorted  \nminOperations([2, 1])        // 1 - reverse both elements\nminOperations([1, 2, 3])     // 0 - already sorted\nminOperations([3, 2, 1])     // 1 - reverse entire array\nminOperations([1, 3, 2])     // 1 - reverse last two\nminOperations([2, 1, 3])     // 1 - reverse first two  \nminOperations([3, 1, 2])     // 2 - requires multiple operations\n"})})}),"\n",(0,i.jsx)(n.h3,{id:"pancake-sorting-connection",children:"Pancake Sorting Connection"}),"\n",(0,i.jsxs)(n.p,{children:["This problem is related to ",(0,i.jsx)(n.strong,{children:"pancake sorting"})," where you can only reverse prefixes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Standard Pancake Sorting: Can only reverse [0, k]\nOur Problem: Can reverse any subarray [i, j]\n\nOur version is more flexible \u2192 potentially fewer operations needed\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operation-counting-examples",children:"Operation Counting Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"[4, 3, 2, 1] \u2192 [1, 2, 3, 4] in 1 operation:\n- Reverse entire array: [4, 3, 2, 1] \u2192 [1, 2, 3, 4] \u2705\n\n[2, 3, 1] \u2192 [1, 2, 3] in 2 operations:\n- Reverse [0, 2]: [2, 3, 1] \u2192 [1, 3, 2]\n- Reverse [1, 2]: [1, 3, 2] \u2192 [1, 2, 3] \u2705\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BFS Recognition"}),': "This is a shortest path problem"']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Space Understanding"}),": Modeling permutations as graph nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Implementation"}),": Good state encoding and cycle detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complexity Analysis"}),": Understanding the exponential nature but bounded by constraints"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"follow-up-questions",children:"Follow-Up Questions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'"What if N could be larger?"'})," \u2192 Discuss heuristics, A*, pruning strategies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'"How would you optimize further?"'})," \u2192 Bidirectional BFS, better state encoding"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'"What if operations had different costs?"'})," \u2192 Use Dijkstra's algorithm instead"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'"Can you prove optimality?"'})," \u2192 BFS guarantees shortest path for unit weights"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,i.jsxs)(n.h3,{id:"1-weighted-operations",children:["1. ",(0,i.jsx)(n.strong,{children:"Weighted Operations"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Different costs for different reverse operations\npublic int MinOperationsWeighted(int[] arr, int[][] costs) { /* implement */ }\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-bidirectional-bfs",children:["2. ",(0,i.jsx)(n.strong,{children:"Bidirectional BFS"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Search from both start and end simultaneously\npublic int BidirectionalMinOperations(int[] arr) { /* implement */ }\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-limited-operations",children:["3. ",(0,i.jsx)(n.strong,{children:"Limited Operations"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Find minimum operations with at most K moves\npublic int MinOperationsWithLimit(int[] arr, int k) { /* implement */ }\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-path-reconstruction",children:["4. ",(0,i.jsx)(n.strong,{children:"Path Reconstruction"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Return the actual sequence of operations\npublic List<(int, int)> GetMinOperationsPath(int[] arr) { /* implement */ }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"mathematical-properties",children:"Mathematical Properties"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"State Space Size"}),": For permutation of size N, there are N! possible states."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Operation Count"}),": From any state, there are C(N,2) = N(N-1)/2 possible reverse operations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Diameter"}),": Maximum operations needed between any two permutations is bounded but exact value depends on specific constraints."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pancake Number"}),": Classical pancake sorting requires at most 2N-3 operations. Our problem typically needs fewer due to more flexibility."]}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"BFS for shortest paths"})," when all edge weights are equal",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"State space modeling"})," transforms combinatorial problems into graph problems",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"Efficient encoding"})," crucial for performance with large state spaces",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"Early termination"})," saves computation when target is found",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"Constraint exploitation"})," makes brute force viable for small N"]}),"\n",(0,i.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,i.jsx)(n.p,{children:"Master these related challenges:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/pancake-sorting/",children:(0,i.jsx)(n.strong,{children:"Pancake Sorting"})})," - Classic variant with prefix-only reversals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/sliding-puzzle/",children:(0,i.jsx)(n.strong,{children:"Sliding Puzzle"})})," - Similar state space BFS approach"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:(0,i.jsx)(n.strong,{children:"Word Ladder"})})," - BFS in string transformation space"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/open-the-lock/",children:(0,i.jsx)(n.strong,{children:"Open the Lock"})})," - State space exploration with constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/",children:(0,i.jsx)(n.strong,{children:"Minimum Swaps to Sort Array"})})," - Related permutation sorting problem"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"This problem showcases the power of modeling combinatorial optimization as graph traversal, where BFS guarantees finding the optimal solution by exploring the state space level by level!"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var r=t(4164);const i={tabItem:"tabItem_Ymn6"};var a=t(4848);function s({children:e,hidden:n,className:t}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,t),hidden:n,children:e})}}}]);