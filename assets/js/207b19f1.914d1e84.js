"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1527],{7984:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"complexity/index","title":"Big O Complexity Guide","description":"Understanding algorithmic complexity is crucial for coding interviews and software engineering. This guide covers everything you need to know about Big O notation, time complexity, and space complexity.","source":"@site/docs/complexity/index.md","sourceDirName":"complexity","slug":"/complexity/","permalink":"/docs/complexity/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/complexity/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Code Puzzle Interview Prep","permalink":"/docs/intro"},"next":{"title":"1 Billion Users","permalink":"/docs/puzzles/billion-users"}}');var s=i(4848),t=i(8453);const l={},a="Big O Complexity Guide",o={},c=[{value:"What is Big O Notation?",id:"what-is-big-o-notation",level:2},{value:"Key Principles",id:"key-principles",level:3},{value:"Common Time Complexities",id:"common-time-complexities",level:2},{value:"O(1) - Constant Time",id:"o1---constant-time",level:3},{value:"O(log n) - Logarithmic Time",id:"olog-n---logarithmic-time",level:3},{value:"O(n) - Linear Time",id:"on---linear-time",level:3},{value:"O(n log n) - Linearithmic Time",id:"on-log-n---linearithmic-time",level:3},{value:"O(n\xb2) - Quadratic Time",id:"on---quadratic-time",level:3},{value:"O(2\u207f) - Exponential Time",id:"o2\u207f---exponential-time",level:3},{value:"Space Complexity",id:"space-complexity",level:2},{value:"Types of Space Usage",id:"types-of-space-usage",level:3},{value:"Common Space Complexities",id:"common-space-complexities",level:3},{value:"Complexity Comparison Table",id:"complexity-comparison-table",level:2},{value:"Practical Analysis Tips",id:"practical-analysis-tips",level:2},{value:"1. <strong>Identify Loops and Recursion</strong>",id:"1-identify-loops-and-recursion",level:3},{value:"2. <strong>Watch for Hidden Complexity</strong>",id:"2-watch-for-hidden-complexity",level:3},{value:"3. <strong>Amortized Analysis</strong>",id:"3-amortized-analysis",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Want to Hear",id:"what-interviewers-want-to-hear",level:3},{value:"Common Complexity Questions",id:"common-complexity-questions",level:3},{value:"Red Flags to Avoid",id:"red-flags-to-avoid",level:3},{value:"Mastering Complexity Analysis",id:"mastering-complexity-analysis",level:2}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"big-o-complexity-guide",children:"Big O Complexity Guide"})}),"\n",(0,s.jsxs)(n.p,{children:["Understanding ",(0,s.jsx)(n.strong,{children:"algorithmic complexity"})," is crucial for coding interviews and software engineering. This guide covers everything you need to know about ",(0,s.jsx)(n.strong,{children:"Big O notation"}),", ",(0,s.jsx)(n.strong,{children:"time complexity"}),", and ",(0,s.jsx)(n.strong,{children:"space complexity"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"what-is-big-o-notation",children:"What is Big O Notation?"}),"\n",(0,s.jsxs)(n.p,{children:["Big O notation describes how an algorithm's ",(0,s.jsx)(n.strong,{children:"performance scales"})," with input size. It answers: ",(0,s.jsx)(n.em,{children:'"As the input gets larger, how much slower does my algorithm get?"'})]}),"\n",(0,s.jsx)(n.h3,{id:"key-principles",children:"Key Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Focus on growth rate"})," - We care about trends, not exact running times"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Worst-case analysis"})," - Assume the most challenging input scenario"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Drop constants"})," - O(2n) becomes O(n)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Drop lower terms"})," - O(n\xb2 + n) becomes O(n\xb2)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-time-complexities",children:"Common Time Complexities"}),"\n",(0,s.jsx)(n.h3,{id:"o1---constant-time",children:"O(1) - Constant Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance doesn't change with input size"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Array access, hash table lookup\nint GetFirst(int[] arr) {\n    return arr[0]; // Always takes same time\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Array indexing, hash table operations, stack push/pop"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"olog-n---logarithmic-time",children:"O(log n) - Logarithmic Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance increases logarithmically with input size"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Binary search\nint BinarySearch(int[] arr, int target) {\n    int left = 0, right = arr.Length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        \n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    \n    return -1;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Binary search, balanced tree operations, divide-and-conquer algorithms"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"on---linear-time",children:"O(n) - Linear Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance scales directly with input size"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Single loop through array\nint FindMax(int[] arr) {\n    int max = arr[0];\n    for (int i = 1; i < arr.Length; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n    return max;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Array traversal, linear search, string operations"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"on-log-n---linearithmic-time",children:"O(n log n) - Linearithmic Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Combination of linear and logarithmic growth"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Merge sort, quicksort (average case)\nvoid MergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = (left + right) / 2;\n        MergeSort(arr, left, mid);     // log n levels\n        MergeSort(arr, mid + 1, right);\n        Merge(arr, left, mid, right);  // O(n) merge\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Efficient sorting algorithms, divide-and-conquer with linear merge"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"on---quadratic-time",children:"O(n\xb2) - Quadratic Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance scales with square of input size"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Nested loops over same data\nvoid BubbleSort(int[] arr) {\n    for (int i = 0; i < arr.Length; i++) {\n        for (int j = 0; j < arr.Length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap elements\n                (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Bubble sort, selection sort, naive matrix multiplication"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"o2\u207f---exponential-time",children:"O(2\u207f) - Exponential Time"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance doubles with each additional input"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Naive recursive Fibonacci\nint Fibonacci(int n) {\n    if (n <= 1) return n;\n    return Fibonacci(n - 1) + Fibonacci(n - 2); // Branches exponentially\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Examples"}),": Brute force subset generation, naive recursive solutions"]}),"\n",(0,s.jsx)(n.h2,{id:"space-complexity",children:"Space Complexity"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Space complexity"})," measures how much ",(0,s.jsx)(n.strong,{children:"additional memory"})," an algorithm uses as input size grows."]}),"\n",(0,s.jsx)(n.h3,{id:"types-of-space-usage",children:"Types of Space Usage"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input space"})," - Memory for input data (usually not counted)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auxiliary space"})," - Extra memory used by algorithm"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Total space"})," - Input + auxiliary space"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-space-complexities",children:"Common Space Complexities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// O(1) space - only using a few variables\nint Sum(int[] arr) {\n    int total = 0; // O(1) extra space\n    foreach (int num in arr) {\n        total += num;\n    }\n    return total;\n}\n\n// O(n) space - creating new data structure\nint[] CreateCopy(int[] arr) {\n    int[] copy = new int[arr.Length]; // O(n) space\n    Array.Copy(arr, copy, arr.Length);\n    return copy;\n}\n\n// O(log n) space - recursive call stack\nint BinarySearchRecursive(int[] arr, int target, int left, int right) {\n    if (left > right) return -1;\n    \n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) return mid;\n    \n    // Recursive calls use O(log n) stack space\n    if (arr[mid] < target) \n        return BinarySearchRecursive(arr, target, mid + 1, right);\n    else \n        return BinarySearchRecursive(arr, target, left, mid - 1);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"complexity-comparison-table",children:"Complexity Comparison Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Complexity"}),(0,s.jsx)(n.th,{children:"10 items"}),(0,s.jsx)(n.th,{children:"100 items"}),(0,s.jsx)(n.th,{children:"1,000 items"}),(0,s.jsx)(n.th,{children:"10,000 items"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(1)"})}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(log n)"})}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"7"}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"13"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(n)"})}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"1,000"}),(0,s.jsx)(n.td,{children:"10,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(n log n)"})}),(0,s.jsx)(n.td,{children:"30"}),(0,s.jsx)(n.td,{children:"700"}),(0,s.jsx)(n.td,{children:"10,000"}),(0,s.jsx)(n.td,{children:"130,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(n\xb2)"})}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"10,000"}),(0,s.jsx)(n.td,{children:"1,000,000"}),(0,s.jsx)(n.td,{children:"100,000,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"O(2\u207f)"})}),(0,s.jsx)(n.td,{children:"1,024"}),(0,s.jsx)(n.td,{children:"~10\xb3\u2070"}),(0,s.jsx)(n.td,{children:"~10\xb3\u2070\u2070"}),(0,s.jsx)(n.td,{children:"Impossible"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"practical-analysis-tips",children:"Practical Analysis Tips"}),"\n",(0,s.jsxs)(n.h3,{id:"1-identify-loops-and-recursion",children:["1. ",(0,s.jsx)(n.strong,{children:"Identify Loops and Recursion"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Single loop = O(n)\nfor (int i = 0; i < n; i++) { ... }\n\n// Nested loops = O(n\xb2) \nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) { ... }\n}\n\n// Recursive calls = depends on depth and branching\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-watch-for-hidden-complexity",children:["2. ",(0,s.jsx)(n.strong,{children:"Watch for Hidden Complexity"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// This looks O(n) but is actually O(n\xb2)!\nstring result = "";\nfor (int i = 0; i < n; i++) {\n    result += arr[i]; // String concatenation is O(n)\n}\n\n// Better: use StringBuilder for O(n) total\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < n; i++) {\n    sb.Append(arr[i]); // Amortized O(1)\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"3-amortized-analysis",children:["3. ",(0,s.jsx)(n.strong,{children:"Amortized Analysis"})]}),"\n",(0,s.jsx)(n.p,{children:"Some operations are expensive occasionally but cheap on average:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ArrayList resize"})," - O(n) occasionally, O(1) amortized"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hash table rehashing"})," - O(n) occasionally, O(1) amortized"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"what-interviewers-want-to-hear",children:"What Interviewers Want to Hear"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State the complexity"})," - Always analyze time and space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explain your reasoning"})," - Show how you arrived at the complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider trade-offs"})," - Discuss when you'd choose different approaches"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize if needed"})," - Can you improve the complexity?"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-complexity-questions",children:"Common Complexity Questions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:'"What\'s the time complexity of your solution?"'})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:'"Can we do better than O(n\xb2)?"'})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:'"How much extra space does this use?"'})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:'"What happens as the input gets very large?"'})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"red-flags-to-avoid",children:"Red Flags to Avoid"}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsx)(n.strong,{children:"\"I think it's O(n) but I'm not sure\""})," - Always analyze carefully",(0,s.jsx)(n.br,{}),"\n","\u274c ",(0,s.jsx)(n.strong,{children:"Ignoring space complexity"})," - Discuss both time and space",(0,s.jsx)(n.br,{}),"\n","\u274c ",(0,s.jsx)(n.strong,{children:"Missing hidden complexity"})," - Watch for expensive operations in loops",(0,s.jsx)(n.br,{}),"\n","\u274c ",(0,s.jsx)(n.strong,{children:"Not considering optimization"})," - Show you can think about improvements"]}),"\n",(0,s.jsx)(n.h2,{id:"mastering-complexity-analysis",children:"Mastering Complexity Analysis"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Practice identifying patterns"})," - Loops, recursion, data structure operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trace through examples"})," - Walk through small inputs to verify analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learn common complexities"})," - Memorize complexity of standard algorithms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Think about trade-offs"})," - Understand when to optimize time vs. space"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Understanding Big O notation isn't just about passing interviews - it's essential for writing efficient, scalable software that performs well as your user base grows."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Ready to apply complexity analysis? Check out our ",(0,s.jsx)(n.a,{href:"/docs/intro",children:"coding puzzles"})," where every solution includes detailed complexity breakdowns!"]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);