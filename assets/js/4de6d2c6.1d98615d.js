"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4023],{1470:(e,n,t)=>{t.d(n,{A:()=>w});var i=t(6540),a=t(4164),r=t(3104),s=t(6347),l=t(205),o=t(7485),c=t(1682),d=t(679);function m(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return m(e).map(({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,o.aZ)(a),(0,i.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})},[a,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=u(e),[s,o]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r})),[c,m]=p({queryString:t,groupId:a}),[g,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,a]=(0,d.Dv)(n);return[t,(0,i.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),b=(()=>{const e=c??g;return h({value:e,tabValues:r})?e:null})();(0,l.A)(()=>{b&&o(b)},[b]);return{selectedValue:s,selectValue:(0,i.useCallback)(e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),m(e),x(e)},[m,x,r]),tabValues:r}}var x=t(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(4848);function j({className:e,block:n,selectedValue:t,selectValue:i,tabValues:s}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.a_)(),c=e=>{const n=e.currentTarget,a=l.indexOf(n),r=s[a].value;r!==t&&(o(n),i(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:i})=>(0,y.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...i,className:(0,a.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function f(e){const n=g(e);return(0,y.jsxs)("div",{className:(0,a.A)("tabs-container",b.tabList),children:[(0,y.jsx)(j,{...n,...e}),(0,y.jsx)(v,{...n,...e})]})}function w(e){const n=(0,x.A)();return(0,y.jsx)(f,{...e,children:m(e.children)},String(n))}},6587:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"puzzles/slow-sums","title":"Slow Sums","description":"Problem Statement","source":"@site/docs/puzzles/slow-sums.mdx","sourceDirName":"puzzles","slug":"/puzzles/slow-sums","permalink":"/code-puzzles/docs/puzzles/slow-sums","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/slow-sums.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Seating Arrangements","permalink":"/code-puzzles/docs/puzzles/seating-arrangements"}}');var a=t(4848),r=t(8453),s=t(1470),l=t(9365);const o={},c="Slow Sums",d={},m=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Visual Understanding",id:"visual-understanding",level:2},{value:"Penalty Contribution Analysis",id:"penalty-contribution-analysis",level:3},{value:"Approach Breakdown",id:"approach-breakdown",level:2},{value:"Why Greedy Works?",id:"why-greedy-works",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Step-by-Step Greedy Solution",id:"step-by-step-greedy-solution",level:3},{value:"Optimized Implementation with Custom Max-Heap",id:"optimized-implementation-with-custom-max-heap",level:3},{value:"Mathematical Analysis Solution",id:"mathematical-analysis-solution",level:3},{value:"Trace-Based Solution",id:"trace-based-solution",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Time Complexity: <strong>O(n log n)</strong>",id:"time-complexity-on-log-n",level:3},{value:"Space Complexity: <strong>O(n)</strong>",id:"space-complexity-on",level:3},{value:"Edge Cases Deep Dive",id:"edge-cases-deep-dive",level:2},{value:"All-Same Values Analysis",id:"all-same-values-analysis",level:3},{value:"Mathematical Pattern",id:"mathematical-pattern",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Follow-Up Questions",id:"follow-up-questions",level:3},{value:"Advanced Variations",id:"advanced-variations",level:2},{value:"1. <strong>Minimize Total Penalty</strong>",id:"1-minimize-total-penalty",level:3},{value:"2. <strong>Weighted Penalties</strong>",id:"2-weighted-penalties",level:3},{value:"3. <strong>K-Way Merging</strong>",id:"3-k-way-merging",level:3},{value:"4. <strong>Dynamic Programming Verification</strong>",id:"4-dynamic-programming-verification",level:3},{value:"Mathematical Properties",id:"mathematical-properties",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Problems",id:"practice-problems",level:2}];function u(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"slow-sums",children:"Slow Sums"})}),"\n","\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Given a list of N numbers, repeatedly choose two numbers and replace them with their sum until only one remains. Each operation incurs a ",(0,a.jsx)(n.strong,{children:"penalty equal to the new sum"}),". Find the ",(0,a.jsx)(n.strong,{children:"maximum possible total penalty"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Function Signature"}),": ",(0,a.jsx)(n.code,{children:"int getTotalTime(int[] arr)"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Input"}),": Array of N integers (1 \u2264 N \u2264 10^6, 1 \u2264 arr[i] \u2264 10^7)",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Output"}),": Maximum possible total penalty"]}),"\n",(0,a.jsxs)(n.admonition,{title:"Real-World Applications",type:"tip",children:[(0,a.jsx)(n.p,{children:"This greedy optimization pattern appears in:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compiler Optimization"}),": Expression evaluation with cost minimization/maximization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Merging"}),": Combining resources with cumulative costs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Financial Planning"}),": Investment combining strategies with fees"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manufacturing"}),": Component assembly with processing costs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Network Design"}),": Connection merging with bandwidth costs"]}),"\n"]})]}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Master greedy algorithm strategies for optimization"}),"\n",(0,a.jsx)(n.li,{children:"Understand when to maximize vs minimize in similar problems"}),"\n",(0,a.jsx)(n.li,{children:"Learn to identify optimal merging strategies"}),"\n",(0,a.jsx)(n.li,{children:"Practice dynamic programming concepts in merge operations"}),"\n",(0,a.jsx)(n.li,{children:"Apply priority queue techniques for efficient implementation"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"visual-understanding",children:"Visual Understanding"}),"\n",(0,a.jsxs)(n.p,{children:["Let's trace through example: ",(0,a.jsx)(n.code,{children:"[4, 2, 1, 3]"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Goal: Maximize total penalty by choosing merge order strategically\n\nStrategy: Always merge the two LARGEST numbers\n(opposite of Huffman coding which minimizes by merging smallest)\n\nStep 1: [4, 2, 1, 3] \u2192 Merge largest: 4 + 3 = 7\n        Penalty: 7, Remaining: [7, 2, 1]\n\nStep 2: [7, 2, 1] \u2192 Merge largest: 7 + 2 = 9  \n        Penalty: 7 + 9 = 16, Remaining: [9, 1]\n\nStep 3: [9, 1] \u2192 Merge remaining: 9 + 1 = 10\n        Penalty: 16 + 10 = 26, Remaining: [10]\n\nTotal penalty: 26\n\nAlternative (suboptimal):\nStep 1: [4, 2, 1, 3] \u2192 Merge smallest: 1 + 2 = 3\n        Penalty: 3, Remaining: [4, 3, 3]\nStep 2: [4, 3, 3] \u2192 Merge: 3 + 3 = 6\n        Penalty: 3 + 6 = 9, Remaining: [4, 6]  \nStep 3: [4, 6] \u2192 Merge: 4 + 6 = 10\n        Penalty: 9 + 10 = 19, Remaining: [10]\n\nTotal penalty: 19 < 26 (suboptimal)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"penalty-contribution-analysis",children:"Penalty Contribution Analysis"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Understanding why largest-first maximizes penalty:\n\nWhen we merge numbers a and b \u2192 (a + b):\n- The penalty is (a + b)\n- The new number (a + b) can participate in future operations\n- Larger numbers contribute to more operations if merged early\n\nExample: [1, 2, 3, 4]\nMerge 4+3=7: penalty 7, contributes to 2 more operations\nMerge 1+2=3: penalty 3, contributes to 2 more operations\n\nIf 4 is in final merge, it only contributes to 1 operation\nIf 4 is merged early, it contributes to multiple operations\n"})}),"\n",(0,a.jsx)(n.h2,{id:"approach-breakdown",children:"Approach Breakdown"}),"\n",(0,a.jsx)(n.h3,{id:"why-greedy-works",children:"Why Greedy Works?"}),"\n",(0,a.jsxs)(n.p,{children:["The slow sums problem demonstrates ",(0,a.jsx)(n.strong,{children:"greedy maximization"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Early Large Merges"}),": Large numbers participate in more operations when merged early"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cumulative Effect"}),": Each intermediate sum becomes input for future operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimal Substructure"}),": Local optimal choices lead to global optimum"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Opposite of Huffman"}),": Huffman minimizes cost by merging smallest; we maximize by merging largest"]}),"\n"]}),"\n",(0,a.jsxs)(s.A,{children:[(0,a.jsxs)(l.A,{value:"wrong",label:"\u274c Wrong Strategy",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Minimize-Like Approach"}),": Merge smallest numbers first"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// This minimizes total penalty (like Huffman coding)\nwhile (numbers.Count > 1) {\n    // Take two SMALLEST numbers\n    int a = numbers.Min();\n    numbers.Remove(a);\n    int b = numbers.Min();\n    numbers.Remove(b);\n    \n    int sum = a + b;\n    totalPenalty += sum;\n    numbers.Add(sum);\n}\n// Result: MINIMUM penalty, not maximum!\n"})})]}),(0,a.jsxs)(l.A,{value:"correct",label:"\u2705 Correct Strategy",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Maximize by Merging Largest"}),": Always take two largest available"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Use max-heap to efficiently get largest numbers\nPriorityQueue<int> maxHeap;\nwhile (maxHeap.Count > 1) {\n    int largest1 = maxHeap.Dequeue();\n    int largest2 = maxHeap.Dequeue();\n    \n    int sum = largest1 + largest2;\n    totalPenalty += sum;\n    maxHeap.Enqueue(sum);\n}\n"})})]})]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"step-by-step-greedy-solution",children:"Step-by-Step Greedy Solution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="SlowSums.cs"',children:'using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass SlowSums \n{\n    static void Main(string[] args) \n    {\n        // Test case 1: Basic example\n        int[] arr1 = {4, 2, 1, 3};\n        Console.WriteLine($"Input: [{string.Join(", ", arr1)}]");\n        Console.WriteLine($"Max penalty: {getTotalTime(arr1)}"); // Expected: 26\n        \n        // Test case 2: Ascending order  \n        int[] arr2 = {1, 2, 3, 4, 5};\n        Console.WriteLine($"Input: [{string.Join(", ", arr2)}]");\n        Console.WriteLine($"Max penalty: {getTotalTime(arr2)}"); // Expected: ?\n        \n        // Test case 3: All same values\n        int[] arr3 = {5, 5, 5, 5};\n        Console.WriteLine($"Input: [{string.Join(", ", arr3)}]");\n        Console.WriteLine($"Max penalty: {getTotalTime(arr3)}"); // Expected: ?\n        \n        // Test case 4: Single element\n        int[] arr4 = {10};\n        Console.WriteLine($"Input: [{string.Join(", ", arr4)}]");\n        Console.WriteLine($"Max penalty: {getTotalTime(arr4)}"); // Expected: 0\n    }\n    \n    private static int getTotalTime(int[] arr) \n    {\n        // Edge case: single element requires no merges\n        if (arr.Length <= 1) return 0;\n        \n        // Use max-heap to efficiently access largest elements\n        // Simulate max-heap with SortedSet (descending order)\n        var maxHeap = new SortedSet<(int value, int id)>(\n            Comparer<(int, int)>.Create((a, b) => {\n                // Primary: sort by value descending (max-heap)\n                int result = b.value.CompareTo(a.value);\n                if (result != 0) return result;\n                // Secondary: sort by id ascending (for uniqueness)\n                return a.id.CompareTo(b.id);\n            })\n        );\n        \n        // Initialize heap with unique IDs to handle duplicates\n        for (int i = 0; i < arr.Length; i++) \n        {\n            maxHeap.Add((arr[i], i));\n        }\n        \n        int totalPenalty = 0;\n        int nextId = arr.Length; // For new merged elements\n        \n        // Keep merging until only one element remains\n        while (maxHeap.Count > 1) \n        {\n            // Get two largest elements\n            var largest1 = maxHeap.Max;\n            maxHeap.Remove(largest1);\n            \n            var largest2 = maxHeap.Max;\n            maxHeap.Remove(largest2);\n            \n            // Merge them and add penalty\n            int mergedValue = largest1.value + largest2.value;\n            totalPenalty += mergedValue;\n            \n            // Add merged result back to heap\n            maxHeap.Add((mergedValue, nextId++));\n        }\n        \n        return totalPenalty;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optimized-implementation-with-custom-max-heap",children:"Optimized Implementation with Custom Max-Heap"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="OptimizedSlowSums.cs"',children:"using System;\nusing System.Collections.Generic;\n\nclass OptimizedSlowSums \n{\n    private static int getTotalTime(int[] arr) \n    {\n        if (arr.Length <= 1) return 0;\n        \n        // Use custom max-heap for better performance\n        var maxHeap = new MaxHeap();\n        \n        // Add all elements to heap\n        foreach (int value in arr) \n        {\n            maxHeap.Insert(value);\n        }\n        \n        int totalPenalty = 0;\n        \n        // Merge until one element remains\n        while (maxHeap.Size() > 1) \n        {\n            int largest1 = maxHeap.ExtractMax();\n            int largest2 = maxHeap.ExtractMax();\n            \n            int sum = largest1 + largest2;\n            totalPenalty += sum;\n            \n            maxHeap.Insert(sum);\n        }\n        \n        return totalPenalty;\n    }\n}\n\n// Custom MaxHeap implementation\nclass MaxHeap \n{\n    private List<int> heap = new List<int>();\n    \n    public void Insert(int value) \n    {\n        heap.Add(value);\n        BubbleUp(heap.Count - 1);\n    }\n    \n    public int ExtractMax() \n    {\n        if (heap.Count == 0) return 0;\n        \n        int max = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        \n        if (heap.Count > 0) BubbleDown(0);\n        return max;\n    }\n    \n    public int Size() => heap.Count;\n    public bool IsEmpty() => heap.Count == 0;\n    \n    private void BubbleUp(int index) \n    {\n        while (index > 0) \n        {\n            int parent = (index - 1) / 2;\n            if (heap[parent] >= heap[index]) break;\n            \n            Swap(parent, index);\n            index = parent;\n        }\n    }\n    \n    private void BubbleDown(int index) \n    {\n        while (true) \n        {\n            int largest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            \n            if (left < heap.Count && heap[left] > heap[largest])\n                largest = left;\n            if (right < heap.Count && heap[right] > heap[largest])\n                largest = right;\n            \n            if (largest == index) break;\n            \n            Swap(index, largest);\n            index = largest;\n        }\n    }\n    \n    private void Swap(int i, int j) => (heap[i], heap[j]) = (heap[j], heap[i]);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"mathematical-analysis-solution",children:"Mathematical Analysis Solution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="MathematicalSlowSums.cs"',children:'class MathematicalSlowSums \n{\n    private static int getTotalTime(int[] arr) \n    {\n        if (arr.Length <= 1) return 0;\n        \n        // Mathematical insight: each number contributes based on its "merge depth"\n        // Numbers merged later contribute to more operations\n        \n        Array.Sort(arr); // Sort for systematic processing\n        Array.Reverse(arr); // Largest first\n        \n        // Simulate the greedy merging process\n        var values = new List<int>(arr);\n        int totalPenalty = 0;\n        \n        while (values.Count > 1) \n        {\n            // Always merge the two largest (first two in sorted desc order)\n            values.Sort((a, b) => b.CompareTo(a)); // Keep sorted descending\n            \n            int largest1 = values[0];\n            int largest2 = values[1];\n            int sum = largest1 + largest2;\n            \n            totalPenalty += sum;\n            \n            // Remove the two largest and add their sum\n            values.RemoveAt(0);\n            values[0] = sum; // Replace second largest with sum\n        }\n        \n        return totalPenalty;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"trace-based-solution",children:"Trace-Based Solution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="TracingSlowSums.cs"',children:'class TracingSlowSums \n{\n    private static int getTotalTime(int[] arr) \n    {\n        if (arr.Length <= 1) return 0;\n        \n        var numbers = new List<int>(arr);\n        int totalPenalty = 0;\n        int step = 1;\n        \n        Console.WriteLine($"Initial: [{string.Join(", ", numbers)}]");\n        \n        while (numbers.Count > 1) \n        {\n            // Find two largest numbers\n            numbers.Sort((a, b) => b.CompareTo(a));\n            \n            int largest1 = numbers[0];\n            int largest2 = numbers[1];\n            int sum = largest1 + largest2;\n            \n            totalPenalty += sum;\n            \n            Console.WriteLine($"Step {step}: Merge {largest1} + {largest2} = {sum}, Penalty: {sum}, Total: {totalPenalty}");\n            \n            // Update the list\n            numbers.RemoveAt(0);\n            numbers[0] = sum;\n            \n            Console.WriteLine($"Remaining: [{string.Join(", ", numbers)}]");\n            step++;\n        }\n        \n        return totalPenalty;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,a.jsxs)(n.h3,{id:"time-complexity-on-log-n",children:["Time Complexity: ",(0,a.jsx)(n.strong,{children:"O(n log n)"})]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operation"}),(0,a.jsx)(n.th,{children:"Time per Iteration"}),(0,a.jsx)(n.th,{children:"Total for (n-1) Iterations"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Extract Max"})}),(0,a.jsx)(n.td,{children:"O(log n)"}),(0,a.jsx)(n.td,{children:"O(n log n)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Insert"})}),(0,a.jsx)(n.td,{children:"O(log n)"}),(0,a.jsx)(n.td,{children:"O(n log n)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Heap Maintenance"})}),(0,a.jsx)(n.td,{children:"O(log n)"}),(0,a.jsx)(n.td,{children:"O(n log n)"})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Overall"}),": O(n log n) time complexity"]}),"\n",(0,a.jsxs)(n.h3,{id:"space-complexity-on",children:["Space Complexity: ",(0,a.jsx)(n.strong,{children:"O(n)"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Heap Storage"}),": O(n) for storing all elements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Additional Variables"}),": O(1)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No recursion"}),": Iterative approach"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"edge-cases-deep-dive",children:"Edge Cases Deep Dive"}),"\n",(0,a.jsx)(n.admonition,{title:"Critical Test Cases",type:"warning",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Test comprehensive edge cases:\n\ngetTotalTime([])              // Empty array \u2192 0\ngetTotalTime([5])             // Single element \u2192 0 (no merges needed)\ngetTotalTime([1, 1])          // Two identical \u2192 2 (penalty = 1+1)\ngetTotalTime([1, 2, 3])       // Small ascending \u2192 trace manually\ngetTotalTime([10, 10, 10])    // All identical values\ngetTotalTime([1, 1000000])    // Extreme value difference\ngetTotalTime([1,2,3,4,5,6,7]) // Longer sequence\n"})})}),"\n",(0,a.jsx)(n.h3,{id:"all-same-values-analysis",children:"All-Same Values Analysis"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Input: [5, 5, 5, 5]\n\nStep 1: Merge 5 + 5 = 10, Remaining: [10, 5, 5]\nStep 2: Merge 10 + 5 = 15, Remaining: [15, 5]  \nStep 3: Merge 15 + 5 = 20, Remaining: [20]\n\nTotal penalty: 10 + 15 + 20 = 45\n\nNote: Even with identical values, greedy max-merge is optimal\n"})}),"\n",(0,a.jsx)(n.h3,{id:"mathematical-pattern",children:"Mathematical Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"For array [1, 2, 3, 4]:\n\nGreedy (largest first):\n- Merge 4+3=7: penalty 7, remaining [7,2,1]\n- Merge 7+2=9: penalty 16, remaining [9,1] \n- Merge 9+1=10: penalty 26, final [10]\nTotal: 26\n\nEach element's contribution:\n- 4: appears in operations 1, 2, 3 \u2192 contributes 4\xd73 = 12\n- 3: appears in operations 1, 2, 3 \u2192 contributes 3\xd73 = 9  \n- 2: appears in operations 2, 3 \u2192 contributes 2\xd72 = 4\n- 1: appears in operation 3 \u2192 contributes 1\xd71 = 1\nTotal: 12+9+4+1 = 26 \u2713\n"})}),"\n",(0,a.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,a.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Greedy Recognition"}),": Understanding when largest-first maximizes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Contrast with Huffman"}),": Recognizing the opposite strategy"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Priority Queue Usage"}),": Efficient max-heap implementation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Mathematical Insight"}),": Understanding contribution patterns"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"follow-up-questions",children:"Follow-Up Questions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"What if we wanted to minimize instead?"'})," \u2192 Use min-heap (Huffman-like)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"How would you handle very large numbers?"'})," \u2192 Discuss overflow and long types"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"Can you prove the greedy choice is optimal?"'})," \u2192 Exchange argument"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"What about negative numbers?"'})," \u2192 Still works, but changes interpretation"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,a.jsxs)(n.h3,{id:"1-minimize-total-penalty",children:["1. ",(0,a.jsx)(n.strong,{children:"Minimize Total Penalty"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Use min-heap instead of max-heap (Huffman coding approach)\npublic int MinimizeTotalPenalty(int[] arr) { /* implement */ }\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"2-weighted-penalties",children:["2. ",(0,a.jsx)(n.strong,{children:"Weighted Penalties"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Different weights for different merge operations\npublic int WeightedSlowSums(int[] arr, double[] weights) { /* implement */ }\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"3-k-way-merging",children:["3. ",(0,a.jsx)(n.strong,{children:"K-Way Merging"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Merge k numbers at a time instead of just 2\npublic int KWaySlowSums(int[] arr, int k) { /* implement */ }\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"4-dynamic-programming-verification",children:["4. ",(0,a.jsx)(n.strong,{children:"Dynamic Programming Verification"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Verify greedy result using DP (for smaller inputs)\npublic int DPSlowSums(int[] arr) { /* implement with memoization */ }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"mathematical-properties",children:"Mathematical Properties"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optimal Strategy"}),": Always merge the two largest available numbers"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Contribution Formula"}),": Each element contributes ",(0,a.jsx)(n.code,{children:"value \xd7 (number of operations it participates in)"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Relationship to Huffman"}),": Opposite strategy - Huffman minimizes by merging smallest first"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Time vs Space Tradeoff"}),": Priority queue uses O(n) space for O(log n) operations"]}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 ",(0,a.jsx)(n.strong,{children:"Greedy maximization"})," works by involving large numbers in more operations",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Priority queues"})," enable efficient access to extreme values",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Opposite of Huffman"})," - maximum vs minimum optimization strategies",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Mathematical insight"})," helps understand contribution patterns",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Edge cases"})," include single elements and identical values"]}),"\n",(0,a.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,a.jsx)(n.p,{children:"Master these related challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-cost-to-connect-sticks/",children:(0,a.jsx)(n.strong,{children:"Minimum Cost to Connect Sticks"})})," - Opposite strategy (minimize)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:(0,a.jsx)(n.strong,{children:"Merge k Sorted Lists"})})," - Priority queue merging"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/",children:(0,a.jsx)(n.strong,{children:"Huffman Coding"})})," - Classic min-merge algorithm"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://www.geeksforgeeks.org/optimal-binary-search-tree-dp-24/",children:(0,a.jsx)(n.strong,{children:"Optimal Binary Search Tree"})})," - Weighted tree construction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/stone-game/",children:(0,a.jsx)(n.strong,{children:"Stone Game"})})," - Strategic number merging"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"This problem beautifully illustrates how greedy algorithms can maximize costs by strategic ordering, contrasting with the more common minimization patterns like Huffman coding!"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var i=t(4164);const a={tabItem:"tabItem_Ymn6"};var r=t(4848);function s({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,t),hidden:n,children:e})}}}]);