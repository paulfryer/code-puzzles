"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2488],{1470:(e,n,i)=>{i.d(n,{A:()=>y});var t=i(6540),a=i(4164),r=i(3104),l=i(6347),s=i(205),d=i(7485),o=i(1682),c=i(679);function h(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:i}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t}))}(i);return function(e){const n=(0,o.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,i])}function u({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const i=(0,l.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(a),(0,t.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(i.location.search);n.set(a,e),i.replace({...i.location,search:n.toString()})},[a,i])]}function g(e){const{defaultValue:n,queryString:i=!1,groupId:a}=e,r=p(e),[l,d]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find(e=>e.default)??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:r})),[o,h]=m({queryString:i,groupId:a}),[g,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,a]=(0,c.Dv)(n);return[i,(0,t.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),f=(()=>{const e=o??g;return u({value:e,tabValues:r})?e:null})();(0,s.A)(()=>{f&&d(f)},[f]);return{selectedValue:l,selectValue:(0,t.useCallback)(e=>{if(!u({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),x(e)},[h,x,r]),tabValues:r}}var x=i(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=i(4848);function v({className:e,block:n,selectedValue:i,selectValue:t,tabValues:l}){const s=[],{blockElementScrollPositionUntilNextRender:d}=(0,r.a_)(),o=e=>{const n=e.currentTarget,a=s.indexOf(n),r=l[a].value;r!==i&&(d(n),t(r))},c=e=>{let n=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const i=s.indexOf(e.currentTarget)+1;n=s[i]??s[0];break}case"ArrowLeft":{const i=s.indexOf(e.currentTarget)-1;n=s[i]??s[s.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:t})=>(0,j.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{s.push(e)},onKeyDown:c,onClick:o,...t,className:(0,a.A)("tabs__item",f.tabItem,t?.className,{"tabs__item--active":i===e}),children:n??e},e))})}function b({lazy:e,children:n,selectedValue:i}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===i);return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function w(e){const n=g(e);return(0,j.jsxs)("div",{className:(0,a.A)("tabs-container",f.tabList),children:[(0,j.jsx)(v,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function y(e){const n=(0,x.A)();return(0,j.jsx)(w,{...e,children:h(e.children)},String(n))}},6969:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"puzzles/median-stream","title":"Median Stream","description":"Problem Statement","source":"@site/docs/puzzles/median-stream.mdx","sourceDirName":"puzzles","slug":"/puzzles/median-stream","permalink":"/docs/puzzles/median-stream","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/median-stream.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Matching Pairs","permalink":"/docs/puzzles/matching-pairs"},"next":{"title":"Minimizing Permutations","permalink":"/docs/puzzles/minimizing-permutations"}}');var a=i(4848),r=i(8453),l=i(1470),s=i(9365);const d={},o="Median Stream",c={},h=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Visual Understanding",id:"visual-understanding",level:2},{value:"Two-Heap Strategy Visualization",id:"two-heap-strategy-visualization",level:3},{value:"Approach Breakdown",id:"approach-breakdown",level:2},{value:"Why Two Heaps?",id:"why-two-heaps",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Step-by-Step Solution",id:"step-by-step-solution",level:3},{value:"Optimized Binary Heap Implementation",id:"optimized-binary-heap-implementation",level:3},{value:"Compact Implementation",id:"compact-implementation",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Time Complexity: <strong>O(n log n)</strong>",id:"time-complexity-on-log-n",level:3},{value:"Space Complexity: <strong>O(n)</strong>",id:"space-complexity-on",level:3},{value:"Edge Cases Deep Dive",id:"edge-cases-deep-dive",level:2},{value:"Integer Division Behavior",id:"integer-division-behavior",level:3},{value:"Heap Balance Scenarios",id:"heap-balance-scenarios",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Follow-Up Questions",id:"follow-up-questions",level:3},{value:"Advanced Variations",id:"advanced-variations",level:2},{value:"1. <strong>Sliding Window Median</strong>",id:"1-sliding-window-median",level:3},{value:"2. <strong>Weighted Median</strong>",id:"2-weighted-median",level:3},{value:"3. <strong>Online Percentile</strong>",id:"3-online-percentile",level:3},{value:"4. <strong>Multi-Threaded Stream</strong>",id:"4-multi-threaded-stream",level:3},{value:"Mathematical Properties",id:"mathematical-properties",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Problems",id:"practice-problems",level:2}];function p(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"median-stream",children:"Median Stream"})}),"\n","\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Given a list of n integers ",(0,a.jsx)(n.code,{children:"arr[0..(n-1)]"}),", compute ",(0,a.jsx)(n.code,{children:"output[0..(n-1)]"})," where ",(0,a.jsx)(n.code,{children:"output[i]"})," equals the ",(0,a.jsx)(n.strong,{children:"median"})," of elements ",(0,a.jsx)(n.code,{children:"arr[0..i]"}),", rounded down to the nearest integer."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Median definition"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Odd count"}),": Middle element in sorted order"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Even count"}),": Average of two middle elements in sorted order (rounded down)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Function Signature"}),": ",(0,a.jsx)(n.code,{children:"int[] findMedian(int[] arr)"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Input"}),": Array of n integers (1 \u2264 n \u2264 1,000,000), each ",(0,a.jsx)(n.code,{children:"arr[i]"})," in range [1, 1,000,000]",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Output"}),": Array of n integers representing running medians"]}),"\n",(0,a.jsxs)(n.admonition,{title:"Real-World Applications",type:"tip",children:[(0,a.jsx)(n.p,{children:"This streaming median pattern is crucial in:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Financial Trading"}),": Real-time market data analysis and moving averages"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Monitoring"}),": Dynamic system metrics and SLA tracking"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Analytics"}),": Online statistics for large datasets"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Control"}),": Manufacturing process monitoring"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gaming"}),": Dynamic difficulty adjustment based on performance metrics"]}),"\n"]})]}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Master dual-heap technique for efficient median tracking"}),"\n",(0,a.jsx)(n.li,{children:"Understand streaming algorithms and online processing"}),"\n",(0,a.jsx)(n.li,{children:"Learn to balance data structures for optimal performance"}),"\n",(0,a.jsx)(n.li,{children:"Practice heap operations and maintain invariants"}),"\n",(0,a.jsx)(n.li,{children:"Apply the two-heap pattern for statistical computations"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"visual-understanding",children:"Visual Understanding"}),"\n",(0,a.jsxs)(n.p,{children:["Let's trace through example: ",(0,a.jsx)(n.code,{children:"[5, 15, 1, 3]"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Position 0: [5]\n  - Sorted: [5]\n  - Count: 1 (odd) \u2192 Median: 5\n  \nPosition 1: [5, 15]  \n  - Sorted: [5, 15]\n  - Count: 2 (even) \u2192 Median: (5 + 15) / 2 = 10\n\nPosition 2: [5, 15, 1]\n  - Sorted: [1, 5, 15] \n  - Count: 3 (odd) \u2192 Median: 5\n\nPosition 3: [5, 15, 1, 3]\n  - Sorted: [1, 3, 5, 15]\n  - Count: 4 (even) \u2192 Median: (3 + 5) / 2 = 4\n\nResult: [5, 10, 5, 4]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"two-heap-strategy-visualization",children:"Two-Heap Strategy Visualization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Maintain two heaps with invariant:\n- Left Heap (Max): Contains smaller half of elements\n- Right Heap (Min): Contains larger half of elements  \n- Balance: |left| = |right| or |left| = |right| + 1\n\nExample: Processing [5, 15, 1, 3]\n\nStep 1: Add 5\n  Left: [5]  Right: []\n  Sizes: 1, 0 \u2192 Median: 5 (top of left)\n\nStep 2: Add 15  \n  Left: [5]  Right: [15]\n  Sizes: 1, 1 \u2192 Median: (5 + 15)/2 = 10\n\nStep 3: Add 1\n  Left: [5, 1]  Right: [15]    (1 goes to left, max-heapify)\n  Left: [5, 1] \u2192 rebalanced: [5]  Right: [1] \u2192 moves to [1, 15]\n  Final: Left: [1, 5] Right: [15]  \n  Sizes: 2, 1 \u2192 Median: 5 (top of left)\n\nStep 4: Add 3\n  Left: [1, 5] Right: [15] \u2192 Add 3 to left \u2192 [1, 3, 5]\n  Rebalance: Left: [1, 3] Right: [5, 15]\n  Sizes: 2, 2 \u2192 Median: (3 + 5)/2 = 4\n"})}),"\n",(0,a.jsx)(n.h2,{id:"approach-breakdown",children:"Approach Breakdown"}),"\n",(0,a.jsx)(n.h3,{id:"why-two-heaps",children:"Why Two Heaps?"}),"\n",(0,a.jsxs)(n.p,{children:["The streaming median problem demonstrates the ",(0,a.jsx)(n.strong,{children:"two-heap pattern"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Divide & Conquer"}),": Split data into smaller/larger halves"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Efficient Access"}),": O(1) access to median elements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Balance"}),": Maintain invariants as stream grows"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimal Complexity"}),": O(log n) per insertion vs O(n log n) naive sort"]}),"\n"]}),"\n",(0,a.jsxs)(l.A,{children:[(0,a.jsxs)(s.A,{value:"naive",label:"\u274c Naive Approach",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Sort Every Time"}),": Re-sort prefix for each median"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// O(n\xb2log n) - extremely inefficient for large streams\nfor (int i = 0; i < n; i++) {\n    var prefix = arr.Take(i + 1).ToArray();\n    Array.Sort(prefix);\n    \n    if (prefix.Length % 2 == 1) {\n        output[i] = prefix[prefix.Length / 2];\n    } else {\n        int mid1 = prefix[prefix.Length / 2 - 1];\n        int mid2 = prefix[prefix.Length / 2];\n        output[i] = (mid1 + mid2) / 2;\n    }\n}\n"})})]}),(0,a.jsxs)(s.A,{value:"optimal",label:"\u2705 Two-Heap Approach",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Balanced Heaps"}),": Maintain running medians efficiently"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// O(n log n) - optimal for streaming median\n// Max-heap (left): smaller half\n// Min-heap (right): larger half  \n// Balance: |left| - |right| \u2208 {0, 1}\n// Median: left.top or (left.top + right.top)/2\n"})})]})]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"step-by-step-solution",children:"Step-by-Step Solution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="MedianStream.cs"',children:'using System;\nusing System.Collections.Generic;\n\nclass MedianStream \n{\n    static void Main(string[] args) \n    {\n        // Test case 1: Basic example\n        int[] arr1 = {5, 15, 1, 3};\n        Console.WriteLine($"Input: [{string.Join(", ", arr1)}]");\n        Console.WriteLine($"Output: [{string.Join(", ", findMedian(arr1))}]");\n        // Expected: [5, 10, 5, 4]\n        \n        // Test case 2: Two elements\n        int[] arr2 = {1, 2};\n        Console.WriteLine($"Input: [{string.Join(", ", arr2)}]");\n        Console.WriteLine($"Output: [{string.Join(", ", findMedian(arr2))}]");\n        // Expected: [1, 1] (average 1.5 rounded down)\n        \n        // Test case 3: Descending order\n        int[] arr3 = {5, 4, 3, 2, 1};\n        Console.WriteLine($"Input: [{string.Join(", ", arr3)}]");\n        Console.WriteLine($"Output: [{string.Join(", ", findMedian(arr3))}]");\n        // Expected: [5, 4, 4, 3, 3]\n    }\n    \n    private static int[] findMedian(int[] arr) \n    {\n        int n = arr.Length;\n        int[] output = new int[n];\n        \n        var medianFinder = new MedianFinder();\n        \n        for (int i = 0; i < n; i++) \n        {\n            medianFinder.AddNumber(arr[i]);\n            output[i] = medianFinder.GetMedian();\n        }\n        \n        return output;\n    }\n}\n\npublic class MedianFinder \n{\n    // Max-heap for smaller half of numbers (simulate with SortedSet)\n    private SortedSet<(int value, int id)> leftHeap;\n    \n    // Min-heap for larger half of numbers\n    private SortedSet<(int value, int id)> rightHeap;\n    \n    private int insertId; // Unique ID to handle duplicates\n    \n    public MedianFinder() \n    {\n        // Max-heap: sort by value descending, then by ID ascending\n        leftHeap = new SortedSet<(int, int)>(\n            Comparer<(int, int)>.Create((a, b) => {\n                int result = b.value.CompareTo(a.value);\n                return result != 0 ? result : a.id.CompareTo(b.id);\n            })\n        );\n        \n        // Min-heap: sort by value ascending, then by ID ascending  \n        rightHeap = new SortedSet<(int, int)>(\n            Comparer<(int, int)>.Create((a, b) => {\n                int result = a.value.CompareTo(b.value);\n                return result != 0 ? result : a.id.CompareTo(b.id);\n            })\n        );\n        \n        insertId = 0;\n    }\n    \n    public void AddNumber(int num) \n    {\n        insertId++;\n        \n        // Decide which heap to add to\n        if (leftHeap.Count == 0 || num <= leftHeap.Max.value) \n        {\n            leftHeap.Add((num, insertId));\n        } \n        else \n        {\n            rightHeap.Add((num, insertId));\n        }\n        \n        // Balance the heaps\n        BalanceHeaps();\n    }\n    \n    public int GetMedian() \n    {\n        if (leftHeap.Count > rightHeap.Count) \n        {\n            // Odd total count: median is top of left heap\n            return leftHeap.Max.value;\n        } \n        else \n        {\n            // Even total count: median is average of both tops (rounded down)\n            int leftMax = leftHeap.Max.value;\n            int rightMin = rightHeap.Min.value;\n            return (leftMax + rightMin) / 2; // Integer division rounds down\n        }\n    }\n    \n    private void BalanceHeaps() \n    {\n        // Maintain invariant: |left| - |right| \u2208 {0, 1}\n        \n        if (leftHeap.Count > rightHeap.Count + 1) \n        {\n            // Move largest from left to right\n            var element = leftHeap.Max;\n            leftHeap.Remove(element);\n            rightHeap.Add(element);\n        }\n        else if (rightHeap.Count > leftHeap.Count) \n        {\n            // Move smallest from right to left  \n            var element = rightHeap.Min;\n            rightHeap.Remove(element);\n            leftHeap.Add(element);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optimized-binary-heap-implementation",children:"Optimized Binary Heap Implementation"}),"\n",(0,a.jsx)(n.p,{children:"For better performance, implement custom binary heaps:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="OptimizedMedianStream.cs"',children:"using System;\nusing System.Collections.Generic;\n\nclass MedianStream \n{\n    private static int[] findMedian(int[] arr) \n    {\n        int n = arr.Length;\n        int[] output = new int[n];\n        \n        var medianFinder = new OptimizedMedianFinder();\n        \n        for (int i = 0; i < n; i++) \n        {\n            medianFinder.AddNumber(arr[i]);\n            output[i] = medianFinder.GetMedian();\n        }\n        \n        return output;\n    }\n}\n\npublic class OptimizedMedianFinder \n{\n    private MaxHeap leftHeap;  // Smaller half\n    private MinHeap rightHeap; // Larger half\n    \n    public OptimizedMedianFinder() \n    {\n        leftHeap = new MaxHeap();\n        rightHeap = new MinHeap();\n    }\n    \n    public void AddNumber(int num) \n    {\n        // Add to appropriate heap\n        if (leftHeap.IsEmpty() || num <= leftHeap.Peek()) \n        {\n            leftHeap.Insert(num);\n        } \n        else \n        {\n            rightHeap.Insert(num);\n        }\n        \n        // Balance heaps\n        if (leftHeap.Size() > rightHeap.Size() + 1) \n        {\n            rightHeap.Insert(leftHeap.ExtractMax());\n        }\n        else if (rightHeap.Size() > leftHeap.Size()) \n        {\n            leftHeap.Insert(rightHeap.ExtractMin());\n        }\n    }\n    \n    public int GetMedian() \n    {\n        if (leftHeap.Size() > rightHeap.Size()) \n        {\n            return leftHeap.Peek();\n        } \n        else \n        {\n            return (leftHeap.Peek() + rightHeap.Peek()) / 2;\n        }\n    }\n}\n\n// Custom MaxHeap implementation\nclass MaxHeap \n{\n    private List<int> heap = new List<int>();\n    \n    public void Insert(int value) \n    {\n        heap.Add(value);\n        BubbleUp(heap.Count - 1);\n    }\n    \n    public int ExtractMax() \n    {\n        if (heap.Count == 0) return 0;\n        \n        int max = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        \n        if (heap.Count > 0) BubbleDown(0);\n        return max;\n    }\n    \n    public int Peek() => heap.Count > 0 ? heap[0] : 0;\n    public int Size() => heap.Count;\n    public bool IsEmpty() => heap.Count == 0;\n    \n    private void BubbleUp(int index) \n    {\n        while (index > 0) \n        {\n            int parent = (index - 1) / 2;\n            if (heap[parent] >= heap[index]) break;\n            \n            Swap(parent, index);\n            index = parent;\n        }\n    }\n    \n    private void BubbleDown(int index) \n    {\n        while (true) \n        {\n            int largest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            \n            if (left < heap.Count && heap[left] > heap[largest])\n                largest = left;\n            if (right < heap.Count && heap[right] > heap[largest])\n                largest = right;\n            \n            if (largest == index) break;\n            \n            Swap(index, largest);\n            index = largest;\n        }\n    }\n    \n    private void Swap(int i, int j) => (heap[i], heap[j]) = (heap[j], heap[i]);\n}\n\n// Custom MinHeap implementation  \nclass MinHeap \n{\n    private List<int> heap = new List<int>();\n    \n    public void Insert(int value) \n    {\n        heap.Add(value);\n        BubbleUp(heap.Count - 1);\n    }\n    \n    public int ExtractMin() \n    {\n        if (heap.Count == 0) return 0;\n        \n        int min = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        \n        if (heap.Count > 0) BubbleDown(0);\n        return min;\n    }\n    \n    public int Peek() => heap.Count > 0 ? heap[0] : 0;\n    public int Size() => heap.Count;\n    public bool IsEmpty() => heap.Count == 0;\n    \n    private void BubbleUp(int index) \n    {\n        while (index > 0) \n        {\n            int parent = (index - 1) / 2;\n            if (heap[parent] <= heap[index]) break;\n            \n            Swap(parent, index);\n            index = parent;\n        }\n    }\n    \n    private void BubbleDown(int index) \n    {\n        while (true) \n        {\n            int smallest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            \n            if (left < heap.Count && heap[left] < heap[smallest])\n                smallest = left;\n            if (right < heap.Count && heap[right] < heap[smallest])\n                smallest = right;\n            \n            if (smallest == index) break;\n            \n            Swap(index, smallest);\n            index = smallest;\n        }\n    }\n    \n    private void Swap(int i, int j) => (heap[i], heap[j]) = (heap[j], heap[i]);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"compact-implementation",children:"Compact Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="CompactMedianStream.cs"',children:"using System;\nusing System.Collections.Generic;\n\nclass MedianStream \n{\n    static int[] findMedian(int[] arr) \n    {\n        var left = new SortedSet<int>(); // Max-heap simulation (smaller half)\n        var right = new SortedSet<int>(); // Min-heap (larger half)\n        var result = new int[arr.Length];\n        \n        for (int i = 0; i < arr.Length; i++) \n        {\n            // Add to appropriate heap\n            if (left.Count == 0 || arr[i] <= left.Max) \n                left.Add(arr[i]);\n            else \n                right.Add(arr[i]);\n            \n            // Balance: ensure |left| - |right| \u2208 {0, 1}\n            if (left.Count > right.Count + 1) \n            {\n                right.Add(left.Max);\n                left.Remove(left.Max);\n            }\n            else if (right.Count > left.Count) \n            {\n                left.Add(right.Min);\n                right.Remove(right.Min);\n            }\n            \n            // Calculate median\n            result[i] = left.Count > right.Count ? \n                        left.Max : \n                        (left.Max + right.Min) / 2;\n        }\n        \n        return result;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,a.jsxs)(n.h3,{id:"time-complexity-on-log-n",children:["Time Complexity: ",(0,a.jsx)(n.strong,{children:"O(n log n)"})]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operation"}),(0,a.jsx)(n.th,{children:"Time"}),(0,a.jsx)(n.th,{children:"Frequency"}),(0,a.jsx)(n.th,{children:"Total"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Heap Insert"})}),(0,a.jsx)(n.td,{children:"O(log k)"}),(0,a.jsx)(n.td,{children:"n times"}),(0,a.jsx)(n.td,{children:"O(n log n)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Balance Operation"})}),(0,a.jsx)(n.td,{children:"O(log k)"}),(0,a.jsx)(n.td,{children:"\u2264 n times"}),(0,a.jsx)(n.td,{children:"O(n log n)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Median Calculation"})}),(0,a.jsx)(n.td,{children:"O(1)"}),(0,a.jsx)(n.td,{children:"n times"}),(0,a.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"Where k \u2264 n is the current heap size."}),"\n",(0,a.jsxs)(n.h3,{id:"space-complexity-on",children:["Space Complexity: ",(0,a.jsx)(n.strong,{children:"O(n)"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Heap Storage"}),": O(n) total across both heaps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Left Heap"}),": Stores \u2248 n/2 elements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Right Heap"}),": Stores \u2248 n/2 elements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Auxiliary Space"}),": O(1) for variables"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"edge-cases-deep-dive",children:"Edge Cases Deep Dive"}),"\n",(0,a.jsx)(n.admonition,{title:"Critical Test Cases",type:"warning",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Test comprehensive edge cases:\n\nfindMedian([1])           // [1] - single element\nfindMedian([1, 2])        // [1, 1] - even count, average rounded down\nfindMedian([2, 1])        // [2, 1] - reverse order  \nfindMedian([1, 1, 1])     // [1, 1, 1] - all duplicates\nfindMedian([1, 100])      // [1, 50] - large difference\nfindMedian([5, 15, 1, 3]) // [5, 10, 5, 4] - mixed pattern\n"})})}),"\n",(0,a.jsx)(n.h3,{id:"integer-division-behavior",children:"Integer Division Behavior"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Median calculation with integer division (rounds down)\n(3 + 4) / 2 = 3    // 3.5 \u2192 3\n(1 + 2) / 2 = 1    // 1.5 \u2192 1  \n(10 + 11) / 2 = 10 // 10.5 \u2192 10\n\n// This matches the problem\'s "rounded down" requirement\n'})}),"\n",(0,a.jsx)(n.h3,{id:"heap-balance-scenarios",children:"Heap Balance Scenarios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Valid balances (left, right):\n- (0, 0): Empty - not applicable\n- (1, 0): One element - median is left.max\n- (1, 1): Two elements - median is (left.max + right.min) / 2\n- (2, 1): Three elements - median is left.max\n- (2, 2): Four elements - median is (left.max + right.min) / 2\n\nInvalid balances that trigger rebalancing:\n- (3, 1): Need to move left.max \u2192 right\n- (1, 2): Need to move right.min \u2192 left\n"})}),"\n",(0,a.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,a.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pattern Recognition"}),': "This needs efficient running median - two heaps!"']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Balance Invariant"}),": Understanding why balance is crucial"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edge Case Handling"}),": Empty heaps, single elements, integer division"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimization Awareness"}),": Custom heaps vs built-in data structures"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"follow-up-questions",children:"Follow-Up Questions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"How would you handle k-th percentile?"'})," \u2192 Generalize with weighted heaps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"What if we need to remove elements?"'})," \u2192 Use multiset or handle duplicates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"Can you do this with less space?"'})," \u2192 Discuss streaming vs buffering tradeoffs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'"What about floating-point medians?"'})," \u2192 Use double arithmetic instead"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,a.jsxs)(n.h3,{id:"1-sliding-window-median",children:["1. ",(0,a.jsx)(n.strong,{children:"Sliding Window Median"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Maintain median in sliding window of size k\npublic double[] MedianSlidingWindow(int[] nums, int k) { /* implement */ }\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"2-weighted-median",children:["2. ",(0,a.jsx)(n.strong,{children:"Weighted Median"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Elements have weights, median based on cumulative weight\npublic double WeightedMedian(int[] values, int[] weights) { /* implement */ }\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"3-online-percentile",children:["3. ",(0,a.jsx)(n.strong,{children:"Online Percentile"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Maintain any percentile (not just 50th) dynamically\npublic class PercentileTracker {\n    public void AddNumber(int num) { /* implement */ }\n    public double GetPercentile(int p) { /* implement */ }\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"4-multi-threaded-stream",children:["4. ",(0,a.jsx)(n.strong,{children:"Multi-Threaded Stream"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Handle concurrent updates to median calculation\npublic class ThreadSafeMedianFinder { /* implement */ }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"mathematical-properties",children:"Mathematical Properties"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Heap Invariants"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"All elements in leftHeap \u2264 all elements in rightHeap"}),"\n",(0,a.jsxs)(n.li,{children:["|leftHeap| - |rightHeap| \u2208 ",1]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Median Formula"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"If |leftHeap| > |rightHeap|: median = leftHeap.max"}),"\n",(0,a.jsx)(n.li,{children:"If |leftHeap| = |rightHeap|: median = \u230a(leftHeap.max + rightHeap.min) / 2\u230b"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Balance Complexity"}),": Each rebalancing operation is O(log n), and we do at most O(1) rebalances per insertion."]}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 ",(0,a.jsx)(n.strong,{children:"Two-heap pattern"})," is the gold standard for streaming median problems",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Balance maintenance"})," is crucial - practice the invariant conditions",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Streaming efficiency"})," allows processing of infinite data streams",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Integer arithmetic"}),' handles the "rounded down" requirement naturally',(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Real-world relevance"})," in analytics, monitoring, and financial systems"]}),"\n",(0,a.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,a.jsx)(n.p,{children:"Master these related challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/find-median-from-data-stream/",children:(0,a.jsx)(n.strong,{children:"Find Median from Data Stream"})})," - Direct application"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/sliding-window-median/",children:(0,a.jsx)(n.strong,{children:"Sliding Window Median"})})," - Advanced variant with removal"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/ipo/",children:(0,a.jsx)(n.strong,{children:"IPO"})})," - Two heaps for different purposes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/kth-largest-element-in-a-stream/",children:(0,a.jsx)(n.strong,{children:"Kth Largest Element in a Stream"})})," - Single heap variant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://www.hackerrank.com/challenges/find-the-running-median",children:(0,a.jsx)(n.strong,{children:"Running Median"})})," - HackerRank classic"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"This problem showcases the elegant power of the two-heap pattern for maintaining running statistics efficiently - a fundamental technique every algorithm engineer should master!"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>s});var t=i(6540);const a={},r=t.createContext(a);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>l});i(6540);var t=i(4164);const a={tabItem:"tabItem_Ymn6"};var r=i(4848);function l({children:e,hidden:n,className:i}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(a.tabItem,i),hidden:n,children:e})}}}]);