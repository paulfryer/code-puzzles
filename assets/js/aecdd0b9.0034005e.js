"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9783],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},8612:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"puzzles/matching-pairs","title":"Matching Pairs","description":"Problem Statement","source":"@site/docs/puzzles/matching-pairs.mdx","sourceDirName":"puzzles","slug":"/puzzles/matching-pairs","permalink":"/code-puzzles/docs/puzzles/matching-pairs","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/matching-pairs.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Magical Candy Bars","permalink":"/code-puzzles/docs/puzzles/magical-candy-bars"},"next":{"title":"Median Stream","permalink":"/code-puzzles/docs/puzzles/median-stream"}}');var a=t(4848),i=t(8453);const r={},c="Matching Pairs",l={},h=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Key Insights",id:"key-insights",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function o(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"matching-pairs",children:"Matching Pairs"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Given two strings ",(0,a.jsx)(n.strong,{children:"s"})," and ",(0,a.jsx)(n.strong,{children:"t"})," of equal length, and exactly ",(0,a.jsx)(n.strong,{children:"k"})," character swaps allowed in string ",(0,a.jsx)(n.strong,{children:"s"}),", determine the ",(0,a.jsx)(n.strong,{children:"maximum number of matching positions"})," achievable between the two strings."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Function Signature"}),": ",(0,a.jsx)(n.code,{children:"int MatchingPairs(string s, string t, int k)"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Input"}),": Two equal-length strings and number of swaps allowed",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"Output"}),": Maximum number of positions where s[i] = t[i]"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Input: ",(0,a.jsx)(n.code,{children:'s = "abcd"'}),", ",(0,a.jsx)(n.code,{children:'t = "adcb"'}),", ",(0,a.jsx)(n.code,{children:"k = 2"})]}),"\n",(0,a.jsxs)(n.li,{children:["Output: ",(0,a.jsx)(n.code,{children:"4"})," (can achieve perfect match)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-insights",children:"Key Insights"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Count current matches"})," - Positions already matching"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Find swappable matches"})," - Characters that can be rearranged to match"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize swaps"})," - Use swaps to maximize matches, handle parity"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="MatchingPairs.cs"',children:'using System;\nusing System.Collections.Generic;\n\nclass MatchingPairs \n{\n    static void Main(string[] args) \n    {\n        Console.WriteLine(MatchingPairs("abcd", "adcb", 2)); // 4\n        Console.WriteLine(MatchingPairs("abcd", "abcd", 0)); // 4\n    }\n\n    private static int MatchingPairs(string s, string t, int k) \n    {\n        int n = s.Length;\n        int currentMatches = 0;\n        var sFreq = new Dictionary<char, int>();\n        var tFreq = new Dictionary<char, int>();\n        \n        // Count current matches and character frequencies for mismatches\n        for (int i = 0; i < n; i++) \n        {\n            if (s[i] == t[i]) \n            {\n                currentMatches++;\n            } \n            else \n            {\n                sFreq[s[i]] = sFreq.GetValueOrDefault(s[i], 0) + 1;\n                tFreq[t[i]] = tFreq.GetValueOrDefault(t[i], 0) + 1;\n            }\n        }\n        \n        // Count potential matches (characters that appear in both mismatch sets)\n        int potentialMatches = 0;\n        foreach (var kvp in sFreq) \n        {\n            char ch = kvp.Key;\n            int sCount = kvp.Value;\n            int tCount = tFreq.GetValueOrDefault(ch, 0);\n            potentialMatches += Math.Min(sCount, tCount);\n        }\n        \n        // Calculate maximum achievable matches\n        int swapsNeeded = potentialMatches / 2;\n        int maxNewMatches = Math.Min(k, swapsNeeded) * 2;\n        \n        // Handle remaining swaps\n        int remainingSwaps = k - swapsNeeded;\n        if (remainingSwaps > 0 && currentMatches + maxNewMatches < n) \n        {\n            // If we have extra swaps and haven\'t achieved perfect match,\n            // we might be able to swap back and forth to use extra swaps\n            if (remainingSwaps % 2 == 1) \n            {\n                maxNewMatches = Math.Max(0, maxNewMatches - 2);\n            }\n        }\n        \n        return currentMatches + maxNewMatches;\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Complexity"}),": O(n) time, O(alphabet size) space"]}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 ",(0,a.jsx)(n.strong,{children:"Frequency analysis"})," - Count character mismatches",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Swap optimization"})," - Each swap can create up to 2 matches",(0,a.jsx)(n.br,{}),"\n","\u2705 ",(0,a.jsx)(n.strong,{children:"Parity handling"})," - Consider remaining swaps and their effect"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);