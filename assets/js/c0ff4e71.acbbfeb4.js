"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2431],{529:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"puzzles/queue-removals","title":"Queue Removals","description":"Problem Statement","source":"@site/docs/puzzles/queue-removals.mdx","sourceDirName":"puzzles","slug":"/puzzles/queue-removals","permalink":"/docs/puzzles/queue-removals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/queue-removals.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Number of Visible Nodes","permalink":"/docs/puzzles/number-of-visible-nodes"},"next":{"title":"Seating Arrangements","permalink":"/docs/puzzles/seating-arrangements"}}');var r=i(4848),s=i(8453),a=i(1470),l=i(9365);const o={},u="Queue Removals",d={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Visual Understanding",id:"visual-understanding",level:2},{value:"Approach Breakdown",id:"approach-breakdown",level:2},{value:"Why Queue Simulation?",id:"why-queue-simulation",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Step-by-Step Queue Simulation",id:"step-by-step-queue-simulation",level:3},{value:"Alternative Implementation with LINQ",id:"alternative-implementation-with-linq",level:3},{value:"Optimized Implementation with Direct Comparison",id:"optimized-implementation-with-direct-comparison",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Time Complexity: <strong>O(x\xb2)</strong>",id:"time-complexity-ox",level:3},{value:"Space Complexity: <strong>O(n)</strong>",id:"space-complexity-on",level:3},{value:"Edge Cases Deep Dive",id:"edge-cases-deep-dive",level:2},{value:"Tiebreaker Rules Deep Dive",id:"tiebreaker-rules-deep-dive",level:3},{value:"Value Decrementation Behavior",id:"value-decrementation-behavior",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Follow-Up Questions",id:"follow-up-questions",level:3},{value:"Advanced Variations",id:"advanced-variations",level:2},{value:"1. <strong>Priority Queue Optimization</strong>",id:"1-priority-queue-optimization",level:3},{value:"2. <strong>Minimum Removal Variant</strong>",id:"2-minimum-removal-variant",level:3},{value:"3. <strong>Custom Decrement Rules</strong>",id:"3-custom-decrement-rules",level:3},{value:"4. <strong>Multi-Queue System</strong>",id:"4-multi-queue-system",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"Process Scheduling",id:"process-scheduling",level:3},{value:"Resource Pool Management",id:"resource-pool-management",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Problems",id:"practice-problems",level:2}];function m(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"queue-removals",children:"Queue Removals"})}),"\n","\n",(0,r.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsx)(n.p,{children:"Given an array of n integers representing a queue and integer x, perform x iterations:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pop x elements"})," from front (or all if fewer than x remain)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove element with largest value"})," (earliest in pop order if tied)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decrement remaining popped elements by 1"})," (if positive) and re-queue them"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return 1-based indices"})," of removed elements"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Function Signature"}),": ",(0,r.jsx)(n.code,{children:"int[] findPositions(int[] arr, int x)"}),(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Input"}),": Array arr, iterations x (1 \u2264 x \u2264 316, x \u2264 n \u2264 x\xb2, 1 \u2264 arr[i] \u2264 x)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Output"}),": Array of x integers (1-based indices of removed elements)"]}),"\n",(0,r.jsxs)(n.admonition,{title:"Real-World Applications",type:"tip",children:[(0,r.jsx)(n.p,{children:"This queue simulation pattern appears in:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task Scheduling Systems"}),": Priority-based job removal with penalties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load Balancer Management"}),": Processing queues with degrading priorities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Game Development"}),": Turn-based systems with action point decay"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network Packet Processing"}),": Queue management with priority and TTL"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Database Connection Pools"}),": Managing connections with usage penalties"]}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Master queue data structure operations and simulations"}),"\n",(0,r.jsx)(n.li,{children:"Understand priority-based selection algorithms"}),"\n",(0,r.jsx)(n.li,{children:"Learn to track original positions through transformations"}),"\n",(0,r.jsx)(n.li,{children:"Practice multi-step algorithmic processes"}),"\n",(0,r.jsx)(n.li,{children:"Apply simulation techniques for complex state management"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"visual-understanding",children:"Visual Understanding"}),"\n",(0,r.jsxs)(n.p,{children:["Let's trace through example: ",(0,r.jsx)(n.code,{children:"arr = [1, 2, 2, 3, 4, 5]"}),", ",(0,r.jsx)(n.code,{children:"x = 5"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Initial Queue: [1(1), 2(2), 2(3), 3(4), 4(5), 5(6)] \n(value(originalIndex))\n\nIteration 1: Pop 5 elements\n- Popped: [1(1), 2(2), 2(3), 3(4), 4(5)]\n- Max value: 4 at position 5 \u2192 Remove index 5\n- Decrement & requeue: [0(1), 1(2), 1(3), 2(4)] \u2192 Queue: [5(6), 0(1), 1(2), 1(3), 2(4)]\n\nIteration 2: Pop 5 elements  \n- Popped: [5(6), 0(1), 1(2), 1(3), 2(4)]\n- Max value: 5 at position 6 \u2192 Remove index 6\n- Decrement & requeue: [0(1), 0(2), 0(3), 1(4)] \u2192 Queue: [0(1), 0(2), 0(3), 1(4)]\n\nIteration 3: Pop 4 elements (only 4 left)\n- Popped: [0(1), 0(2), 0(3), 1(4)]\n- Max value: 1 at position 4 \u2192 Remove index 4\n- Decrement & requeue: [0(1), 0(2), 0(3)] \u2192 Queue: [0(1), 0(2), 0(3)]\n\nIteration 4: Pop 3 elements\n- Popped: [0(1), 0(2), 0(3)]\n- All equal, earliest popped wins: 0 at position 1 \u2192 Remove index 1\n- Decrement & requeue: [0(2), 0(3)] \u2192 Queue: [0(2), 0(3)]\n\nIteration 5: Pop 2 elements\n- Popped: [0(2), 0(3)]\n- All equal, earliest popped wins: 0 at position 2 \u2192 Remove index 2\n\nResult: [5, 6, 4, 1, 2]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"approach-breakdown",children:"Approach Breakdown"}),"\n",(0,r.jsx)(n.h3,{id:"why-queue-simulation",children:"Why Queue Simulation?"}),"\n",(0,r.jsxs)(n.p,{children:["This problem demonstrates ",(0,r.jsx)(n.strong,{children:"complex state management"})," with multiple operations per iteration:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Operations"}),": Natural FIFO behavior with pop and requeue"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Priority Selection"}),": Find maximum with tiebreaking rules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Mutation"}),": Elements change values during processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Position Tracking"}),": Maintain original indices throughout transformations"]}),"\n"]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsxs)(l.A,{value:"naive",label:"\u274c Naive Approach",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Array-Based Simulation"}),": Use arrays and linear search"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Inefficient: O(x\xb3) due to repeated linear searches\nfor (int iter = 0; iter < x; iter++) {\n    // Pop x elements: O(x)\n    // Find max with linear search: O(x)  \n    // Requeue elements: O(x)\n    // Total per iteration: O(x)\n    // But finding max requires sorting or multiple passes\n}\n"})})]}),(0,r.jsxs)(l.A,{value:"optimal",label:"\u2705 Queue + Priority Selection",children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Queue with Efficient Max Finding"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"Queue<Element> queue = new Queue<Element>();\n// Pop exactly x elements: O(x)\n// Find max with single pass: O(x)\n// Requeue remaining: O(x)\n// Total per iteration: O(x), overall: O(x\xb2)\n"})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"step-by-step-queue-simulation",children:"Step-by-Step Queue Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="QueueRemovals.cs"',children:'using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class QueueElement \n{\n    public int value;\n    public int originalIndex; // 1-based original position\n    \n    public QueueElement(int value, int originalIndex) \n    {\n        this.value = value;\n        this.originalIndex = originalIndex;\n    }\n    \n    public override string ToString() \n    {\n        return $"{value}({originalIndex})";\n    }\n}\n\nclass QueueRemovals \n{\n    static void Main(string[] args) \n    {\n        // Test case 1: Basic example\n        int[] arr1 = {1, 2, 2, 3, 4, 5};\n        int x1 = 5;\n        Console.WriteLine($"Input: [{string.Join(", ", arr1)}], x={x1}");\n        Console.WriteLine($"Output: [{string.Join(", ", findPositions(arr1, x1))}]");\n        // Expected: [5, 6, 4, 1, 2]\n        \n        // Test case 2: All same values\n        int[] arr2 = {2, 2, 2, 2};\n        int x2 = 3;\n        Console.WriteLine($"Input: [{string.Join(", ", arr2)}], x={x2}");\n        Console.WriteLine($"Output: [{string.Join(", ", findPositions(arr2, x2))}]");\n        // Expected: [1, 2, 3] (earliest position wins ties)\n        \n        // Test case 3: Single iteration\n        int[] arr3 = {5, 4, 3, 2, 1};\n        int x3 = 1;\n        Console.WriteLine($"Input: [{string.Join(", ", arr3)}], x={x3}");\n        Console.WriteLine($"Output: [{string.Join(", ", findPositions(arr3, x3))}]");\n        // Expected: [1] (max value 5 at position 1)\n    }\n    \n    private static int[] findPositions(int[] arr, int x) \n    {\n        var queue = new Queue<QueueElement>();\n        \n        // Initialize queue with original elements and 1-based indices\n        for (int i = 0; i < arr.Length; i++) \n        {\n            queue.Enqueue(new QueueElement(arr[i], i + 1));\n        }\n        \n        var result = new int[x];\n        \n        // Perform x iterations\n        for (int iteration = 0; iteration < x; iteration++) \n        {\n            // Step 1: Pop x elements from front (or all if fewer available)\n            var poppedElements = new List<QueueElement>();\n            int elementsToPop = Math.Min(x, queue.Count);\n            \n            for (int i = 0; i < elementsToPop; i++) \n            {\n                poppedElements.Add(queue.Dequeue());\n            }\n            \n            // Step 2: Find element with largest value (earliest position for ties)\n            var maxElement = FindMaxElementWithTiebreaker(poppedElements);\n            \n            // Record the removed element\'s original index\n            result[iteration] = maxElement.originalIndex;\n            \n            // Step 3: Decrement remaining elements and re-queue them\n            foreach (var element in poppedElements) \n            {\n                if (element != maxElement) \n                {\n                    // Decrement if positive, then re-queue\n                    if (element.value > 0) \n                    {\n                        element.value--;\n                    }\n                    queue.Enqueue(element);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private static QueueElement FindMaxElementWithTiebreaker(List<QueueElement> elements) \n    {\n        QueueElement maxElement = elements[0];\n        int maxIndex = 0;\n        \n        for (int i = 1; i < elements.Count; i++) \n        {\n            QueueElement current = elements[i];\n            \n            // Find maximum value with earliest position tiebreaker\n            if (current.value > maxElement.value || \n               (current.value == maxElement.value && i < maxIndex)) \n            {\n                maxElement = current;\n                maxIndex = i;\n            }\n        }\n        \n        return maxElement;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"alternative-implementation-with-linq",children:"Alternative Implementation with LINQ"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="QueueRemovalsLINQ.cs"',children:"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass QueueRemovalsLINQ \n{\n    private static int[] findPositions(int[] arr, int x) \n    {\n        var queue = new Queue<QueueElement>();\n        \n        // Initialize queue\n        for (int i = 0; i < arr.Length; i++) \n        {\n            queue.Enqueue(new QueueElement(arr[i], i + 1));\n        }\n        \n        var result = new int[x];\n        \n        for (int iteration = 0; iteration < x; iteration++) \n        {\n            // Pop up to x elements\n            var popped = new List<QueueElement>();\n            int toPop = Math.Min(x, queue.Count);\n            \n            for (int i = 0; i < toPop; i++) \n            {\n                popped.Add(queue.Dequeue());\n            }\n            \n            // Find max element using LINQ (with position-based tiebreaking)\n            var maxElement = popped\n                .Select((element, index) => new { element, index })\n                .OrderByDescending(x => x.element.value)\n                .ThenBy(x => x.index) // Earliest position wins ties\n                .First().element;\n            \n            result[iteration] = maxElement.originalIndex;\n            \n            // Decrement and re-queue non-max elements\n            foreach (var element in popped.Where(e => e != maxElement)) \n            {\n                if (element.value > 0) element.value--;\n                queue.Enqueue(element);\n            }\n        }\n        \n        return result;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"optimized-implementation-with-direct-comparison",children:"Optimized Implementation with Direct Comparison"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="OptimizedQueueRemovals.cs"',children:"class OptimizedQueueRemovals \n{\n    private static int[] findPositions(int[] arr, int x) \n    {\n        var queue = new Queue<(int value, int originalIndex)>();\n        \n        // Initialize with tuples for cleaner code\n        for (int i = 0; i < arr.Length; i++) \n        {\n            queue.Enqueue((arr[i], i + 1));\n        }\n        \n        var result = new int[x];\n        \n        for (int iteration = 0; iteration < x; iteration++) \n        {\n            var popped = new List<(int value, int originalIndex, int popOrder)>();\n            int toPop = Math.Min(x, queue.Count);\n            \n            // Pop elements and track their pop order for tiebreaking\n            for (int i = 0; i < toPop; i++) \n            {\n                var element = queue.Dequeue();\n                popped.Add((element.value, element.originalIndex, i));\n            }\n            \n            // Find max element with manual comparison (avoids LINQ overhead)\n            var maxElement = popped[0];\n            for (int i = 1; i < popped.Count; i++) \n            {\n                var current = popped[i];\n                if (current.value > maxElement.value || \n                    (current.value == maxElement.value && current.popOrder < maxElement.popOrder)) \n                {\n                    maxElement = current;\n                }\n            }\n            \n            result[iteration] = maxElement.originalIndex;\n            \n            // Re-queue non-max elements with decremented values\n            foreach (var element in popped) \n            {\n                if (element.originalIndex != maxElement.originalIndex) \n                {\n                    int newValue = Math.Max(0, element.value - 1);\n                    if (newValue >= 0) // Always re-queue, even if value becomes 0\n                    {\n                        queue.Enqueue((newValue, element.originalIndex));\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.h3,{id:"time-complexity-ox",children:["Time Complexity: ",(0,r.jsx)(n.strong,{children:"O(x\xb2)"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"Time per Iteration"}),(0,r.jsx)(n.th,{children:"Total for x Iterations"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Pop x elements"})}),(0,r.jsx)(n.td,{children:"O(x)"}),(0,r.jsx)(n.td,{children:"O(x\xb2)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Find maximum"})}),(0,r.jsx)(n.td,{children:"O(x)"}),(0,r.jsx)(n.td,{children:"O(x\xb2)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Requeue elements"})}),(0,r.jsx)(n.td,{children:"O(x)"}),(0,r.jsx)(n.td,{children:"O(x\xb2)"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Overall"}),": O(x\xb2) time complexity"]}),"\n",(0,r.jsxs)(n.h3,{id:"space-complexity-on",children:["Space Complexity: ",(0,r.jsx)(n.strong,{children:"O(n)"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Space"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Queue Storage"})}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"Store all elements with metadata"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Popped List"})}),(0,r.jsx)(n.td,{children:"O(x)"}),(0,r.jsx)(n.td,{children:"Temporary storage per iteration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Result Array"})}),(0,r.jsx)(n.td,{children:"O(x)"}),(0,r.jsx)(n.td,{children:"Required output"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Overall"}),": O(n) space complexity"]}),"\n",(0,r.jsx)(n.h2,{id:"edge-cases-deep-dive",children:"Edge Cases Deep Dive"}),"\n",(0,r.jsx)(n.admonition,{title:"Critical Test Cases",type:"warning",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Test comprehensive edge cases:\n\nfindPositions([5], 1)              // Single element\nfindPositions([1, 1, 1, 1], 2)    // All equal values (tiebreaker test)\nfindPositions([5, 4, 3, 2, 1], 1) // Single iteration, clear max\nfindPositions([1, 2, 3], 5)       // x > n (pop all available)\nfindPositions([3, 3, 3], 3)       // All same, sequential removal\nfindPositions([1, 1, 1, 1], 4)    // Values become 0, position-based tiebreaking\n"})})}),"\n",(0,r.jsx)(n.h3,{id:"tiebreaker-rules-deep-dive",children:"Tiebreaker Rules Deep Dive"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"When multiple elements have the same maximum value:\n- Choose the element that was popped EARLIEST in current iteration\n- NOT the element with smallest original index\n- NOT the element currently at front of queue\n\nExample: Popped [2(5), 3(2), 3(7)] \u2192 Max value 3\n- Position 2 was popped first (index 1)\n- Position 7 was popped second (index 2) \n- Choose position 2 as winner\n"})}),"\n",(0,r.jsx)(n.h3,{id:"value-decrementation-behavior",children:"Value Decrementation Behavior"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Values decrement but never go below 0\nint newValue = Math.Max(0, element.value - 1);\n\n// Elements with value 0 still participate in tiebreaking\n// They just can't decrease further\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,r.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Mastery"}),": Proper use of queue operations and FIFO behavior"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simulation Logic"}),": Correctly implementing multi-step process"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tiebreaker Handling"}),': Understanding "earliest popped" rule']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Index Tracking"}),": Maintaining original positions through transformations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"follow-up-questions",children:"Follow-Up Questions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"What if we wanted minimum instead of maximum?"'})," \u2192 Same algorithm, change comparison"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"How to optimize for very large x?"'})," \u2192 Discuss priority queue alternatives"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"What about memory constraints?"'})," \u2192 In-place modifications vs separate tracking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"Can you handle updates to the queue during processing?"'})," \u2192 Dynamic queue management"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,r.jsxs)(n.h3,{id:"1-priority-queue-optimization",children:["1. ",(0,r.jsx)(n.strong,{children:"Priority Queue Optimization"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Use max-heap for faster max-finding\nPriorityQueue<(int value, int originalIndex, int popOrder), (int, int)> maxHeap;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-minimum-removal-variant",children:["2. ",(0,r.jsx)(n.strong,{children:"Minimum Removal Variant"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Remove minimum value instead of maximum\npublic int[] FindPositionsMin(int[] arr, int x) { /* implement */ }\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-custom-decrement-rules",children:["3. ",(0,r.jsx)(n.strong,{children:"Custom Decrement Rules"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Different decrement strategies (e.g., halving, custom function)\npublic int[] FindPositionsCustom(int[] arr, int x, Func<int, int> decrementFunc) { /* implement */ }\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-multi-queue-system",children:["4. ",(0,r.jsx)(n.strong,{children:"Multi-Queue System"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Multiple queues with different priorities\npublic int[] FindPositionsMultiQueue(int[][] queues, int x) { /* implement */ }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,r.jsx)(n.h3,{id:"process-scheduling",children:"Process Scheduling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"- Tasks in queue with priorities\n- Remove highest priority task\n- Reduce remaining task priorities (aging)\n- Track completion order\n"})}),"\n",(0,r.jsx)(n.h3,{id:"resource-pool-management",children:"Resource Pool Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"- Resources with usage counts\n- Allocate most-used resource\n- Decrease usage counters of others\n- Monitor allocation patterns\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Queue simulation"})," requires careful state management across multiple operations",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Tiebreaker rules"}),' are crucial - "earliest popped" not "smallest original index"',(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Index tracking"})," through transformations needs consistent 1-based numbering",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Value mutations"})," happen after selection but before re-queuing",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Edge cases"})," include all-equal values and queue exhaustion scenarios"]}),"\n",(0,r.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,r.jsx)(n.p,{children:"Master these related challenges:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/task-scheduler/",children:(0,r.jsx)(n.strong,{children:"Task Scheduler"})})," - Priority scheduling with cooldowns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/design-hit-counter/",children:(0,r.jsx)(n.strong,{children:"Design Hit Counter"})})," - Sliding window with queue"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/moving-average-from-data-stream/",children:(0,r.jsx)(n.strong,{children:"Moving Average from Data Stream"})})," - Queue-based statistics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/design-phone-directory/",children:(0,r.jsx)(n.strong,{children:"Design Phone Directory"})})," - Resource pool management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/lru-cache/",children:(0,r.jsx)(n.strong,{children:"LRU Cache"})})," - Queue-based cache eviction"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"This problem demonstrates complex queue simulation with priority selection and state mutations - essential skills for system design and process modeling!"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},1470:(e,n,i)=>{i.d(n,{A:()=>y});var t=i(6540),r=i(4164),s=i(3104),a=i(6347),l=i(205),o=i(7485),u=i(1682),d=i(679);function c(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m(e){const{values:n,children:i}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return c(e).map(({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t}))}(i);return function(e){const n=(0,u.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,i])}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const i=(0,a.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,o.aZ)(r),(0,t.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})},[r,i])]}function x(e){const{defaultValue:n,queryString:i=!1,groupId:r}=e,s=m(e),[a,o]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find(e=>e.default)??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:s})),[u,c]=p({queryString:i,groupId:r}),[x,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,r]=(0,d.Dv)(n);return[i,(0,t.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),v=(()=>{const e=u??x;return h({value:e,tabValues:s})?e:null})();(0,l.A)(()=>{v&&o(v)},[v]);return{selectedValue:a,selectValue:(0,t.useCallback)(e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),g(e)},[c,g,s]),tabValues:s}}var g=i(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=i(4848);function f({className:e,block:n,selectedValue:i,selectValue:t,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.a_)(),u=e=>{const n=e.currentTarget,r=l.indexOf(n),s=a[r].value;s!==i&&(o(n),t(s))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;n=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;n=l[i]??l[l.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:t})=>(0,j.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:u,...t,className:(0,r.A)("tabs__item",v.tabItem,t?.className,{"tabs__item--active":i===e}),children:n??e},e))})}function b({lazy:e,children:n,selectedValue:i}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===i);return e?(0,t.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function w(e){const n=x(e);return(0,j.jsxs)("div",{className:(0,r.A)("tabs-container",v.tabList),children:[(0,j.jsx)(f,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function y(e){const n=(0,g.A)();return(0,j.jsx)(w,{...e,children:c(e.children)},String(n))}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>a});i(6540);var t=i(4164);const r={tabItem:"tabItem_Ymn6"};var s=i(4848);function a({children:e,hidden:n,className:i}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(r.tabItem,i),hidden:n,children:e})}}}]);