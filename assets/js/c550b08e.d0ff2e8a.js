"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3411],{1470:(e,n,i)=>{i.d(n,{A:()=>N});var t=i(6540),r=i(4164),s=i(3104),l=i(6347),o=i(205),a=i(7485),d=i(1682),c=i(679);function u(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t}))}(i);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,i])}function v({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const i=(0,l.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,a.aZ)(r),(0,t.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})},[r,i])]}function g(e){const{defaultValue:n,queryString:i=!1,groupId:r}=e,s=h(e),[l,a]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!v({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find(e=>e.default)??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:s})),[d,u]=p({queryString:i,groupId:r}),[g,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,r]=(0,c.Dv)(n);return[i,(0,t.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),m=(()=>{const e=d??g;return v({value:e,tabValues:s})?e:null})();(0,o.A)(()=>{m&&a(m)},[m]);return{selectedValue:l,selectValue:(0,t.useCallback)(e=>{if(!v({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);a(e),u(e),b(e)},[u,b,s]),tabValues:s}}var b=i(2303);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=i(4848);function f({className:e,block:n,selectedValue:i,selectValue:t,tabValues:l}){const o=[],{blockElementScrollPositionUntilNextRender:a}=(0,s.a_)(),d=e=>{const n=e.currentTarget,r=o.indexOf(n),s=l[r].value;s!==i&&(a(n),t(s))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=o.indexOf(e.currentTarget)+1;n=o[i]??o[0];break}case"ArrowLeft":{const i=o.indexOf(e.currentTarget)-1;n=o[i]??o[o.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:t})=>(0,x.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{o.push(e)},onKeyDown:c,onClick:d,...t,className:(0,r.A)("tabs__item",m.tabItem,t?.className,{"tabs__item--active":i===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:i}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===i);return e?(0,t.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function w(e){const n=g(e);return(0,x.jsxs)("div",{className:(0,r.A)("tabs-container",m.tabList),children:[(0,x.jsx)(f,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function N(e){const n=(0,b.A)();return(0,x.jsx)(w,{...e,children:u(e.children)},String(n))}},2241:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>v,frontMatter:()=>a,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"puzzles/number-of-visible-nodes","title":"Number of Visible Nodes","description":"Problem Statement","source":"@site/docs/puzzles/number-of-visible-nodes.mdx","sourceDirName":"puzzles","slug":"/puzzles/number-of-visible-nodes","permalink":"/code-puzzles/docs/puzzles/number-of-visible-nodes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/number-of-visible-nodes.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nodes in a Subtree","permalink":"/code-puzzles/docs/puzzles/nodes-in-a-subtree"},"next":{"title":"Queue Removals","permalink":"/code-puzzles/docs/puzzles/queue-removals"}}');var r=i(4848),s=i(8453),l=i(1470),o=i(9365);const a={},d="Number of Visible Nodes",c={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Visual Understanding",id:"visual-understanding",level:2},{value:"BFS Level Processing Visualization",id:"bfs-level-processing-visualization",level:3},{value:"Approach Breakdown",id:"approach-breakdown",level:2},{value:"Why Level-Order Traversal (BFS)?",id:"why-level-order-traversal-bfs",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Step-by-Step BFS Solution",id:"step-by-step-bfs-solution",level:3},{value:"DFS Alternative Solution",id:"dfs-alternative-solution",level:3},{value:"Optimized Single-Pass DFS",id:"optimized-single-pass-dfs",level:3},{value:"Comprehensive Solution with Edge Cases",id:"comprehensive-solution-with-edge-cases",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Time Complexity: <strong>O(N)</strong>",id:"time-complexity-on",level:3},{value:"Space Complexity: <strong>Varies by approach</strong>",id:"space-complexity-varies-by-approach",level:3},{value:"Edge Cases Deep Dive",id:"edge-cases-deep-dive",level:2},{value:"Tree Shape Impact",id:"tree-shape-impact",level:3},{value:"Level Processing Details",id:"level-processing-details",level:3},{value:"Interview Strategy",id:"interview-strategy",level:2},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Follow-Up Questions",id:"follow-up-questions",level:3},{value:"Advanced Variations",id:"advanced-variations",level:2},{value:"1. <strong>Right Side View</strong>",id:"1-right-side-view",level:3},{value:"2. <strong>Top View</strong>",id:"2-top-view",level:3},{value:"3. <strong>Bottom View</strong>",id:"3-bottom-view",level:3},{value:"4. <strong>Custom Visibility Rules</strong>",id:"4-custom-visibility-rules",level:3},{value:"Mathematical Properties",id:"mathematical-properties",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Problems",id:"practice-problems",level:2}];function h(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"number-of-visible-nodes",children:"Number of Visible Nodes"})}),"\n","\n",(0,r.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Given a binary tree with N nodes, determine how many nodes are ",(0,r.jsx)(n.strong,{children:"visible when viewing the tree from its left side"}),". You can see only the leftmost node at each level (which may be either a left or right child)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Function Signature"}),": ",(0,r.jsx)(n.code,{children:"int visibleNodes(Node root)"}),(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Input"}),": Root node of binary tree (1 \u2264 N \u2264 1000, node values 0 to 1,000,000,000)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Output"}),": Integer representing the number of visible nodes"]}),"\n",(0,r.jsxs)(n.admonition,{title:"Real-World Applications",type:"tip",children:[(0,r.jsx)(n.p,{children:"This spatial tree analysis pattern appears in:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Computer Graphics"}),": Rendering 3D scenes with occlusion culling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UI Layout Systems"}),": Determining visible components in nested hierarchies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Game Development"}),": Line-of-sight calculations and visibility detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Visualization"}),": Tree diagrams and organizational chart rendering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"File System Explorers"}),": Showing expandable folder hierarchies"]}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Master level-order traversal (BFS) for tree problems"}),"\n",(0,r.jsx)(n.li,{children:"Understand tree visualization and spatial reasoning concepts"}),"\n",(0,r.jsx)(n.li,{children:"Learn to process trees level by level efficiently"}),"\n",(0,r.jsx)(n.li,{children:"Practice queue-based algorithms and tree navigation"}),"\n",(0,r.jsx)(n.li,{children:"Apply breadth-first search to solve geometric problems on trees"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"visual-understanding",children:"Visual Understanding"}),"\n",(0,r.jsx)(n.p,{children:"Let's trace through an example tree:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Tree structure:\n       8\n      / \\\n     3   10\n    / \\   \\\n   1   6   14\n      / \\  /\n     4   7 13\n\nLeft side view:\nLevel 0: [8] \u2192 Visible: 8\nLevel 1: [3, 10] \u2192 Visible: 3 (leftmost)\nLevel 2: [1, 6, 14] \u2192 Visible: 1 (leftmost)  \nLevel 3: [4, 7, 13] \u2192 Visible: 4 (leftmost)\n\nTotal visible nodes: 4\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bfs-level-processing-visualization",children:"BFS Level Processing Visualization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Queue Processing:\nInitial: Queue=[8]\n\nLevel 0:\n- Dequeue 8 \u2192 VISIBLE (first at level 0)\n- Enqueue children: Queue=[3, 10]\n\nLevel 1:  \n- Dequeue 3 \u2192 VISIBLE (first at level 1)\n- Enqueue children: Queue=[10, 1, 6]\n- Dequeue 10 \u2192 not visible (not first at level 1)\n- Enqueue children: Queue=[1, 6, 14]\n\nLevel 2:\n- Dequeue 1 \u2192 VISIBLE (first at level 2)  \n- No children: Queue=[6, 14]\n- Dequeue 6 \u2192 not visible\n- Enqueue children: Queue=[14, 4, 7]\n- Dequeue 14 \u2192 not visible\n- Enqueue children: Queue=[4, 7, 13]\n\nLevel 3:\n- Dequeue 4 \u2192 VISIBLE (first at level 3)\n- Continue processing remaining...\n\nResult: 4 visible nodes (8, 3, 1, 4)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"approach-breakdown",children:"Approach Breakdown"}),"\n",(0,r.jsx)(n.h3,{id:"why-level-order-traversal-bfs",children:"Why Level-Order Traversal (BFS)?"}),"\n",(0,r.jsxs)(n.p,{children:["The left side view problem is naturally suited to ",(0,r.jsx)(n.strong,{children:"level-by-level processing"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spatial Reasoning"}),': "Left side view" means first node at each level']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Level Boundaries"}),": BFS naturally processes complete levels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Order Preservation"}),": Left-to-right traversal ensures leftmost is seen first"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complete Coverage"}),": Every level gets exactly one visible node"]}),"\n"]}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsxs)(o.A,{value:"dfs",label:"\u274c DFS Complications",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Depth-First Search"}),": Possible but more complex logic needed"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// DFS requires tracking depth and first-seen status\nHashSet<int> seenDepths = new HashSet<int>();\n\nvoid DFS(TreeNode node, int depth) {\n    if (node == null) return;\n    \n    if (!seenDepths.Contains(depth)) {\n        seenDepths.Add(depth); // First node at this depth\n        visibleCount++;\n    }\n    \n    DFS(node.left, depth + 1);  // Must go left first!\n    DFS(node.right, depth + 1);\n}\n"})})]}),(0,r.jsxs)(o.A,{value:"bfs",label:"\u2705 BFS Natural Fit",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Breadth-First Search"}),": Perfect for level-by-level problems"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"Queue<TreeNode> queue = new Queue<TreeNode>();\nqueue.Enqueue(root);\n\nwhile (queue.Count > 0) {\n    int levelSize = queue.Count;\n    \n    for (int i = 0; i < levelSize; i++) {\n        TreeNode node = queue.Dequeue();\n        \n        if (i == 0) visibleCount++; // First node at level\n        \n        // Add children for next level\n        if (node.left != null) queue.Enqueue(node.left);\n        if (node.right != null) queue.Enqueue(node.right);\n    }\n}\n"})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"step-by-step-bfs-solution",children:"Step-by-Step BFS Solution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="NumberOfVisibleNodes.cs"',children:'using System;\nusing System.Collections.Generic;\n\npublic class TreeNode \n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    \n    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) \n    {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass NumberOfVisibleNodes \n{\n    static void Main(string[] args) \n    {\n        // Test case 1: Example tree\n        //       8\n        //      / \\\n        //     3   10\n        //    / \\   \\\n        //   1   6   14\n        //      / \\  /\n        //     4   7 13\n        \n        var root = new TreeNode(8);\n        root.left = new TreeNode(3);\n        root.right = new TreeNode(10);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(6);\n        root.right.right = new TreeNode(14);\n        root.left.right.left = new TreeNode(4);\n        root.left.right.right = new TreeNode(7);\n        root.right.right.left = new TreeNode(13);\n        \n        Console.WriteLine($"Visible nodes: {visibleNodes(root)}"); // Expected: 4\n        \n        // Test case 2: Right-skewed tree\n        //   1\n        //    \\\n        //     2\n        //      \\\n        //       3\n        var rightSkewed = new TreeNode(1);\n        rightSkewed.right = new TreeNode(2);\n        rightSkewed.right.right = new TreeNode(3);\n        \n        Console.WriteLine($"Right-skewed tree visible nodes: {visibleNodes(rightSkewed)}"); // Expected: 3\n        \n        // Test case 3: Left-skewed tree\n        //     1\n        //    /\n        //   2\n        //  /\n        // 3\n        var leftSkewed = new TreeNode(1);\n        leftSkewed.left = new TreeNode(2);\n        leftSkewed.left.left = new TreeNode(3);\n        \n        Console.WriteLine($"Left-skewed tree visible nodes: {visibleNodes(leftSkewed)}"); // Expected: 3\n    }\n    \n    private static int visibleNodes(TreeNode root) \n    {\n        if (root == null) return 0;\n        \n        var queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        int visibleCount = 0;\n        \n        while (queue.Count > 0) \n        {\n            int levelSize = queue.Count; // Snapshot of current level size\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < levelSize; i++) \n            {\n                TreeNode node = queue.Dequeue();\n                \n                // The first node we encounter at each level is visible from left side\n                if (i == 0) \n                {\n                    visibleCount++;\n                }\n                \n                // Add children to queue for next level processing\n                // Order matters: left first, then right (left-to-right traversal)\n                if (node.left != null) \n                {\n                    queue.Enqueue(node.left);\n                }\n                if (node.right != null) \n                {\n                    queue.Enqueue(node.right);\n                }\n            }\n        }\n        \n        return visibleCount;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dfs-alternative-solution",children:"DFS Alternative Solution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="DFSVisibleNodes.cs"',children:"using System;\nusing System.Collections.Generic;\n\nclass DFSVisibleNodes \n{\n    private static int visibleNodes(TreeNode root) \n    {\n        if (root == null) return 0;\n        \n        var seenDepths = new HashSet<int>();\n        TraverseLeftView(root, 0, seenDepths);\n        \n        return seenDepths.Count;\n    }\n    \n    // Pre-order traversal: root, left, right\n    private static void TraverseLeftView(TreeNode node, int depth, HashSet<int> seenDepths) \n    {\n        if (node == null) return;\n        \n        // If this is the first node we've seen at this depth, it's visible\n        if (!seenDepths.Contains(depth)) \n        {\n            seenDepths.Add(depth);\n        }\n        \n        // Critical: Traverse left subtree first to ensure leftmost nodes get priority\n        TraverseLeftView(node.left, depth + 1, seenDepths);\n        TraverseLeftView(node.right, depth + 1, seenDepths);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"optimized-single-pass-dfs",children:"Optimized Single-Pass DFS"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="OptimizedVisibleNodes.cs"',children:"class OptimizedVisibleNodes \n{\n    private static int visibleCount;\n    private static int maxDepthSeen;\n    \n    private static int visibleNodes(TreeNode root) \n    {\n        visibleCount = 0;\n        maxDepthSeen = -1;\n        \n        TraversePreOrder(root, 0);\n        \n        return visibleCount;\n    }\n    \n    private static void TraversePreOrder(TreeNode node, int depth) \n    {\n        if (node == null) return;\n        \n        // If this is the deepest level we've reached so far, this node is visible\n        if (depth > maxDepthSeen) \n        {\n            visibleCount++;\n            maxDepthSeen = depth;\n        }\n        \n        // Pre-order traversal: left first ensures leftmost nodes are processed first\n        TraversePreOrder(node.left, depth + 1);\n        TraversePreOrder(node.right, depth + 1);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-solution-with-edge-cases",children:"Comprehensive Solution with Edge Cases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="RobustVisibleNodes.cs"',children:"class RobustVisibleNodes \n{\n    public static int VisibleNodes(TreeNode root) \n    {\n        // Handle edge case: empty tree\n        if (root == null) return 0;\n        \n        return BFSLeftView(root);\n    }\n    \n    private static int BFSLeftView(TreeNode root) \n    {\n        var queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        int visibleCount = 0;\n        \n        while (queue.Count > 0) \n        {\n            int currentLevelSize = queue.Count;\n            bool firstNodeInLevel = true;\n            \n            // Process all nodes at current level\n            for (int i = 0; i < currentLevelSize; i++) \n            {\n                TreeNode currentNode = queue.Dequeue();\n                \n                // First node at each level is visible from left side\n                if (firstNodeInLevel) \n                {\n                    visibleCount++;\n                    firstNodeInLevel = false;\n                }\n                \n                // Enqueue children for next level (maintain left-to-right order)\n                if (currentNode.left != null) \n                {\n                    queue.Enqueue(currentNode.left);\n                }\n                if (currentNode.right != null) \n                {\n                    queue.Enqueue(currentNode.right);\n                }\n            }\n        }\n        \n        return visibleCount;\n    }\n    \n    // Alternative: Get actual visible node values (not just count)\n    public static List<int> GetVisibleNodeValues(TreeNode root) \n    {\n        var result = new List<int>();\n        if (root == null) return result;\n        \n        var queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        \n        while (queue.Count > 0) \n        {\n            int levelSize = queue.Count;\n            \n            for (int i = 0; i < levelSize; i++) \n            {\n                TreeNode node = queue.Dequeue();\n                \n                if (i == 0) \n                {\n                    result.Add(node.val); // Store visible node value\n                }\n                \n                if (node.left != null) queue.Enqueue(node.left);\n                if (node.right != null) queue.Enqueue(node.right);\n            }\n        }\n        \n        return result;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.h3,{id:"time-complexity-on",children:["Time Complexity: ",(0,r.jsx)(n.strong,{children:"O(N)"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Approach"}),(0,r.jsx)(n.th,{children:"Time"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"BFS Level-Order"})}),(0,r.jsx)(n.td,{children:"O(N)"}),(0,r.jsx)(n.td,{children:"Visit each node exactly once"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DFS Pre-Order"})}),(0,r.jsx)(n.td,{children:"O(N)"}),(0,r.jsx)(n.td,{children:"Single traversal through all nodes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Both approaches"})}),(0,r.jsx)(n.td,{children:"Optimal"}),(0,r.jsx)(n.td,{children:"Cannot do better than visiting all nodes"})]})]})]}),"\n",(0,r.jsxs)(n.h3,{id:"space-complexity-varies-by-approach",children:["Space Complexity: ",(0,r.jsx)(n.strong,{children:"Varies by approach"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Approach"}),(0,r.jsx)(n.th,{children:"Space"}),(0,r.jsx)(n.th,{children:"Worst Case"}),(0,r.jsx)(n.th,{children:"Best Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"BFS"})}),(0,r.jsx)(n.td,{children:"O(W)"}),(0,r.jsx)(n.td,{children:"O(N) complete tree"}),(0,r.jsx)(n.td,{children:"O(1) linear tree"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DFS"})}),(0,r.jsx)(n.td,{children:"O(H)"}),(0,r.jsx)(n.td,{children:"O(N) skewed tree"}),(0,r.jsx)(n.td,{children:"O(log N) balanced"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Where W = maximum width, H = height, N = total nodes."}),"\n",(0,r.jsx)(n.h2,{id:"edge-cases-deep-dive",children:"Edge Cases Deep Dive"}),"\n",(0,r.jsx)(n.admonition,{title:"Critical Test Cases",type:"warning",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Comprehensive edge case testing:\n\nvisibleNodes(null)                    // 0 - empty tree\nvisibleNodes(new TreeNode(5))         // 1 - single node\nvisibleNodes(leftSkewedTree)          // height - all left children visible  \nvisibleNodes(rightSkewedTree)         // height - all right children visible\nvisibleNodes(completeBinaryTree)      // height + 1 - one per level\nvisibleNodes(zigzagTree)              // varies - mixed left/right structure\n"})})}),"\n",(0,r.jsx)(n.h3,{id:"tree-shape-impact",children:"Tree Shape Impact"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Left-skewed tree:     Right-skewed tree:    Balanced tree:\n    1                      1                      1\n   /                        \\                   /   \\\n  2              vs           2          vs     2     3\n /                             \\               / \\   / \\\n3                               3             4   5 6   7\n\nVisible: 3 (all)       Visible: 3 (all)     Visible: 3 (levels 0,1,2)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"level-processing-details",children:"Level Processing Details"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Level-by-level breakdown for complex tree\nLevel 0: [root] \u2192 1 visible (the root)\nLevel 1: [root.left, root.right] \u2192 1 visible (leftmost)\nLevel 2: [all level 2 nodes] \u2192 1 visible (leftmost)\n...\nLevel k: [all level k nodes] \u2192 1 visible (leftmost)\n\nTotal visible = number of levels = tree height + 1\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interview-strategy",children:"Interview Strategy"}),"\n",(0,r.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BFS Mastery"}),": Natural use of level-order traversal for level-based problems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Management"}),": Proper handling of level boundaries in BFS"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spatial Reasoning"}),': Understanding "left side view" concept']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge Case Handling"}),": Empty trees, single nodes, skewed trees"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"follow-up-questions",children:"Follow-Up Questions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"What about right side view?"'})," \u2192 Same algorithm, take last node at each level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"Return the visible node values?"'})," \u2192 Store values instead of counting"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"What if tree is very wide?"'})," \u2192 Discuss space optimization strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"How to visualize tree vertically?"'})," \u2192 Extend to vertical order traversal"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,r.jsxs)(n.h3,{id:"1-right-side-view",children:["1. ",(0,r.jsx)(n.strong,{children:"Right Side View"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// See nodes from right side instead of left\npublic int RightSideView(TreeNode root) {\n    // Take LAST node at each level instead of first\n    if (i == levelSize - 1) visibleCount++;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-top-view",children:["2. ",(0,r.jsx)(n.strong,{children:"Top View"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// See nodes from top (one per horizontal position)\npublic int TopView(TreeNode root) { /* implement with column tracking */ }\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-bottom-view",children:["3. ",(0,r.jsx)(n.strong,{children:"Bottom View"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// See nodes from bottom (last node at each horizontal position)\npublic int BottomView(TreeNode root) { /* implement with column + level tracking */ }\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-custom-visibility-rules",children:["4. ",(0,r.jsx)(n.strong,{children:"Custom Visibility Rules"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Define custom visibility criteria (e.g., nodes > certain value)\npublic int ConditionalVisibleNodes(TreeNode root, Predicate<TreeNode> condition) { /* implement */ }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"mathematical-properties",children:"Mathematical Properties"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Visible Node Count = Tree Height + 1"})}),"\n",(0,r.jsx)(n.p,{children:"For any binary tree:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Minimum visible nodes = 1 (single node tree)"}),"\n",(0,r.jsx)(n.li,{children:"Maximum visible nodes = N (completely left-skewed or right-skewed)"}),"\n",(0,r.jsx)(n.li,{children:"Balanced tree visible nodes \u2248 log\u2082(N) + 1"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Relationship"}),": Each level contributes exactly one visible node in left side view."]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Level-order traversal"})," is the natural approach for level-based tree problems",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"First node per level"})," defines left side visibility in BFS",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Queue size tracking"})," enables level boundary detection",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Spatial reasoning"})," translates to algorithmic solutions for tree visualization",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Order matters"})," - left-to-right traversal ensures correct visibility"]}),"\n",(0,r.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,r.jsx)(n.p,{children:"Master these related challenges:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-right-side-view/",children:(0,r.jsx)(n.strong,{children:"Binary Tree Right Side View"})})," - Mirror problem for right side"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:(0,r.jsx)(n.strong,{children:"Binary Tree Level Order Traversal"})})," - Foundation BFS technique"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-vertical-order-traversal/",children:(0,r.jsx)(n.strong,{children:"Binary Tree Vertical Order Traversal"})})," - Advanced tree positioning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-width-of-binary-tree/",children:(0,r.jsx)(n.strong,{children:"Maximum Width of Binary Tree"})})," - Width calculation per level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",children:(0,r.jsx)(n.strong,{children:"Binary Tree Zigzag Level Order"})})," - Alternating direction traversal"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:'This problem beautifully demonstrates how spatial reasoning about trees translates to level-order traversal algorithms, showing that "visibility" problems are often disguised BFS challenges!'})})]})}function v(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}},9365:(e,n,i)=>{i.d(n,{A:()=>l});i(6540);var t=i(4164);const r={tabItem:"tabItem_Ymn6"};var s=i(4848);function l({children:e,hidden:n,className:i}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(r.tabItem,i),hidden:n,children:e})}}}]);