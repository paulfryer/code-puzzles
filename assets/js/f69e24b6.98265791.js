"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9523],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},8696:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"puzzles/element-swapping","title":"Element Swapping","description":"Problem Statement","source":"@site/docs/puzzles/element-swapping.mdx","sourceDirName":"puzzles","slug":"/puzzles/element-swapping","permalink":"/code-puzzles/docs/puzzles/element-swapping","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/element-swapping.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Counting Triangles","permalink":"/code-puzzles/docs/puzzles/counting-triangles"},"next":{"title":"Encrypted Words","permalink":"/code-puzzles/docs/puzzles/encrypted-words"}}');var s=t(4848),r=t(8453);const a={},l="Element Swapping",o={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Key Strategy",id:"key-strategy",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function p(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"element-swapping",children:"Element Swapping"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["Given a sequence of ",(0,s.jsx)(n.strong,{children:"n integers"})," and a limit of ",(0,s.jsx)(n.strong,{children:"k consecutive swaps"}),", determine the ",(0,s.jsx)(n.strong,{children:"lexicographically smallest"})," sequence achievable. Each swap can only involve ",(0,s.jsx)(n.strong,{children:"adjacent elements"})," in the current arrangement."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Function Signature"}),": ",(0,s.jsx)(n.code,{children:"int[] FindMinArray(int[] arr, int k)"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Input"}),": Array of integers and maximum number of adjacent swaps allowed",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output"}),": Lexicographically smallest array achievable"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Input: ",(0,s.jsx)(n.code,{children:"[5, 3, 1], k = 2"})]}),"\n",(0,s.jsxs)(n.li,{children:["Output: ",(0,s.jsx)(n.code,{children:"[1, 5, 3]"})," (swap 3,1 then 5,1)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-strategy",children:"Key Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Greedy Approach"}),": For each position from left to right, find the smallest element within reach (k swaps) and bubble it to that position."]}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ElementSwapping.cs"',children:'using System;\n\nclass ElementSwapping \n{\n    static void Main(string[] args) \n    {\n        var result1 = FindMinArray(new int[] {5, 3, 1}, 2);\n        Console.WriteLine($"[{string.Join(", ", result1)}]"); // [1, 5, 3]\n    }\n\n    private static int[] FindMinArray(int[] arr, int k) \n    {\n        int[] result = new int[arr.Length];\n        Array.Copy(arr, result, arr.Length);\n        \n        int remainingSwaps = k;\n        \n        for (int i = 0; i < result.Length && remainingSwaps > 0; i++) \n        {\n            // Find smallest element within k swaps from position i\n            int minIndex = i;\n            int minValue = result[i];\n            \n            for (int j = i + 1; j < result.Length && j <= i + remainingSwaps; j++) \n            {\n                if (result[j] < minValue) \n                {\n                    minValue = result[j];\n                    minIndex = j;\n                }\n            }\n            \n            // Bubble the minimum element to position i\n            while (minIndex > i && remainingSwaps > 0) \n            {\n                // Swap with previous element\n                int temp = result[minIndex];\n                result[minIndex] = result[minIndex - 1];\n                result[minIndex - 1] = temp;\n                \n                minIndex--;\n                remainingSwaps--;\n            }\n        }\n        \n        return result;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complexity"}),": O(n\xb2) time, O(1) space (excluding output)"]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Greedy optimization"})," - Prioritize leftmost positions for smallest elements",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Constrained bubble sort"})," - Adapt classic algorithms to constraints",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Lexicographic ordering"})," - Earlier positions have higher priority"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);