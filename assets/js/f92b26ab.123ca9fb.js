"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4341],{1112:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"puzzles/encrypted-words","title":"Encrypted Words","description":"Problem Statement","source":"@site/docs/puzzles/encrypted-words.mdx","sourceDirName":"puzzles","slug":"/puzzles/encrypted-words","permalink":"/code-puzzles/docs/puzzles/encrypted-words","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/puzzles/encrypted-words.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Element Swapping","permalink":"/code-puzzles/docs/puzzles/element-swapping"},"next":{"title":"Largest Triple Products","permalink":"/code-puzzles/docs/puzzles/largest-triple-products"}}');var s=t(4848),i=t(8453);const d={},l="Encrypted Words",c={},o=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Algorithm Trace",id:"algorithm-trace",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function a(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"encrypted-words",children:"Encrypted Words"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["Given a string ",(0,s.jsx)(n.strong,{children:"s"}),", generate an encrypted version using a specific algorithm:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"If length is 1, return the string as-is"}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, find the middle character (favor left for even lengths)"}),"\n",(0,s.jsx)(n.li,{children:"Recursively encrypt the left substring, then the right substring"}),"\n",(0,s.jsx)(n.li,{children:"Return: middle character + encrypted left + encrypted right"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Function Signature"}),": ",(0,s.jsx)(n.code,{children:"string FindEncryptedWord(string s)"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Input"}),": String to encrypt (1 \u2264 length \u2264 10,000)",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output"}),": Encrypted string using the recursive algorithm"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Input: ",(0,s.jsx)(n.code,{children:'"facebook"'})]}),"\n",(0,s.jsxs)(n.li,{children:["Output: ",(0,s.jsx)(n.code,{children:'"eafcobok"'})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"algorithm-trace",children:"Algorithm Trace"}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:'"facebook"'})," (length 8):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'1. Middle index: (0 + 7) / 2 = 3 \u2192 \'e\'\n2. Left: "fac", Right: "book"  \n3. Encrypt "fac" \u2192 middle=\'a\', left="f", right="c" \u2192 "afc"\n4. Encrypt "book" \u2192 middle=\'o\', left="bo", right="k" \n   - Encrypt "bo" \u2192 "ob"  \n   - Result: "o" + "ob" + "k" = "oobk"\n5. Final: "e" + "afc" + "oobk" = "eafcoobk"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="EncryptedWords.cs"',children:'using System;\n\nclass EncryptedWords \n{\n    static void Main(string[] args) \n    {\n        Console.WriteLine(FindEncryptedWord("abc"));      // "bac"\n        Console.WriteLine(FindEncryptedWord("facebook")); // "eafcobok"  \n    }\n\n    private static string FindEncryptedWord(string s) \n    {\n        // Base case\n        if (s.Length <= 1) \n        {\n            return s;\n        }\n        \n        // Find middle index (favor left for even lengths)\n        int middleIndex = (s.Length - 1) / 2;\n        char middleChar = s[middleIndex];\n        \n        // Split into left and right substrings\n        string left = s.Substring(0, middleIndex);\n        string right = s.Substring(middleIndex + 1);\n        \n        // Recursively encrypt substrings\n        string encryptedLeft = FindEncryptedWord(left);\n        string encryptedRight = FindEncryptedWord(right);\n        \n        // Combine: middle + encrypted left + encrypted right\n        return middleChar + encryptedLeft + encryptedRight;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complexity"}),": O(n log n) time, O(log n) space (recursion depth)"]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Divide and conquer"})," - Break problem into smaller subproblems",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Recursive structure"})," - Self-similar problem decomposition",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Index arithmetic"})," - Careful middle calculation for even/odd lengths"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);